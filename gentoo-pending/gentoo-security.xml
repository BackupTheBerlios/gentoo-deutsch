<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- English CVS Version: 1.11 -->

<guide link = "/doc/en/gentoo-security.xml">
<title>Gentoo Linux Sicherheitsleitfaden</title>

<author title="Autor"><mail link="kn@insecurity.dk">Kim Nielsen</mail></author>
<author title="Bearbeitung"><mail link="zhen@gentoo.org">John P. Davis</mail></author>
<author title="Bearbeitung"><mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail></author>
<author title="Bearbeitung"><mail link="carl@gentoo.org">Carl Anderson</mail></author>
<author title="Bearbeitung"><mail link="peesh@gentoo.org">Jorge Paulo</mail></author>
<author title="Übersetzung"><mail link="beejay@berlios.de">Benjamin Judas</mail></author>
<author title="Übersetzung"><mail link="baka@users.berlios.de">Hendrik Grahl</mail></author>

<abstract>Dieser Leitfaden ist eine Schritt-für-Schritt-Anleitung für das Absichern von Gentoo-Linux</abstract>

<version>0.4</version>
<date>4. Mai 2003</date>

-- Introduction start --

<chapter>
<title>Einleitung</title>

<section>
<title>Wer sollte diesen Leitfaden lesen?</title>
<body>
	<p>
		Leute, die Gentoo-Linux in einer serverbasierten Umgebung einsetzen, und/oder das Bedürfnis nach mehr oder übertriebener
		Sicherheit verspüren.
	</p>
</body>
</section>

<section>
<title>Dank an</title>
<body>
	<p>
		Kim Nielsen
	</p>
</body>
</section>

<section>
<title>Special thanks</title>
<body>
	<p>
		Spezieller Dank geht an die folgenden Personen, weil sie verschiedene Fehler, Rechtschreib- und Satzbaufehler gefunden haben.
	</p>
	<p>
		Bjarke Sørensen, Justin Lambert, Andreas Waschbuesch, Duncan Lissett, Sherman Boyd, Sami Dalouche and Väinö Järvelä.
	</p>
</body>
</section>

<section>
<title>Erweiterungen für die nächste Ausgabe dieses Leitfadens:</title>
<body>
	<p>
		In Version 0.6 (Backup)
	</p>
	<ul>
		<li>Arpwatch</li>
		<li>Komplettes Systembackup mit Hilfe von Systemimager</li>
		<li>Partielles Backup mittels tar</li>
		<li>Backups von PostgreSQL erstellen</li>
	</ul>
	<p>
		In Version 0.8 (Penetrations Tests)
	</p>
	<ul>
		<li>Remote Audits</li>
		<li>Netzwerk Audits</li>
		<li>Host Audits</li>
		<li>Software Audits</li>
	</ul>
	<p>
		In version 1.0 (Nach einem Kompromiss)
	</p>
	<ul>
		<li>Wie meldet man einen Vorfall</li>
		<li>Forensische Analyse</li>
		<li>Erstellen von Systemimages ohne Beweise zu vernichten (mittels <c>dd</c>)</li>
		<li>Fallen stellen und verfolgen (mit tcpdump)</li>
		<li>.. Noch einiges mehr ..</li>
		<li>System wieder herstellen</li>
	</ul>

	<note>
		Bitte beachten Sie, dass sich jede Version jewils nur auf ein Thema bezieht. Dies wird aus
		Qualitätssicherungsgründen so gehandhabt.
	</note>
</body>
</section>
</chapter>

-- Introduction end --

-- Considerations before installation start --

<chapter>
<title>Vor der Installation zu bedenken</title>

<section>
<title>Physische Sicherheit</title>
<body>
	<p>
		Egal wieviele Sicherheitsmassnahmen Sie integrieren, sie können leicht umgangen werden,
		wenn der Hacker direkten Zugriff auf Ihre Maschine hat. Stellen Sie sicher, dass Ihre
		Hardware nicht einfach so zugänglich ist. Zum Beispiel könnten Sie Ihre Maschine in einem
		speziellen Serverraum einschliessen. Die Gehäuse zu versiegeln ist auch eine gute Idee.
		Um das höchste Niveau an Sicherheit zu erreichen, können Sie Ihr BIOS so einstellen, dass
		es nur von der Festplatte bootet. Deaktivieren Sie auch das Booten von Diskette und von
		CD-ROM. Für den übervorsichtigen kann es auch sinnvoll sein, das BIOS-Passwort zu aktivieren.
		BIOS-Passwörter sind auch eine gute Idee für Notebook-Benutzer.
	</p>

</body>
</section>

<section>
<title>Dämon/Dienst Planung</title>
<body>
	<p>
		Dokumentieren Sie, welche Dienste die Maschine anbieten soll oder anbieten darf. Dies wird
		Ihnen helfen ein besseres Partitionsschema für das System zu erstellen. Es kann auch das
		Aufspüren von Eindringlingen erheblich erleichtern.
	</p>
	<p>
		Natürlich brauchen Sie das nicht zu dokumentieren, wenn Sie einen oder ein paar Computer benutzen,
		aber Sie auch der einzige Nutzer sind.
	</p>
	<p>
		Beispiel:
	</p>
	<p>
		Der Computer soll als eine Firewall laufen. Welche Dienste sollte er laufen lassen?
	</p>
	<p>
		<e>keine</e>, u.U. höchstens ssh.
	</p>
	<p>
		Dokumentieren Sie dies und die aktuelle Version von SSH - es wird Ihnen helfen, das zu aktualisierende
		System wiederzufinden - für den Fall, dass jemand ein Sicherheitsloch in sshd findet. Dies wird Ihnen
		auch dabei helfen festzulegen, wer Zugriff auf das System haben sollte.
	</p>
</body>
</section>

<section>
<title>Partitions-Schemata</title>
<body>
	<p>
		Goldene Regeln:
	</p>
	<ul>
		<li>
			Jedes Verzeichnis auf das ein Benutzer Schreibrechte haben muss (/home und /tmp, /var) sollte auf einer
			seperaten Partition sein und Disk-Quotas benutzen. Portage benutzt /var/tmp zum kompilieren, folglich muss
			diese Partition gross sein. Dies reduziert das Risiko, daß ein Benutzer "/" komplett füllen kann.
		</li>
		<li>
			Jedes Verzeichnis, in das nicht in der Distribution enthaltene Pakete installiert werden sollen, sollten auf einer seperaten Partition liegen.
			Nach dem <uri link="http://www.pathname.com/fhs/">File Hierarchy Standard</uri> ist dies <path>/opt</path>
			oder /usr/local. Wenn diese seperate Partitionen sein, dann werden sie nicht gelöscht, sollte einmal die Notwendigkeit bestehen, daß System
			neu zu installieren.
		</li>
		<li>
			Versuchen sie, statische Daten in eine eigene Partition verschieben und diese Partition nur lesbar einhängen. Wenn sie wirklich
			übervorsichtig sind, dann könnten Sie statische Daten auch auf einem nur lesbaren Medium speichern - zum Beispiel einer CD-ROM.
		</li>
	</ul>
</body>
</section>

<section>
<title>Der Benutzer root</title>
<body>
	<p>
		Der Benutzer 'root' ist der mächtigste Benutzer im System und sollte nie für irgendetwas Anderes als administrative
		Aufgaben eingesetzt werden. Wenn ein Angreifer root-Zugang erreicht, dann können Sie Ihrem System nicht mehr länger trauen - Sie
		haben dann keine andere Wahl, als neu zu installieren.
	</p>
	<p>
		Goldene Regeln bezüglich 'root'
	</p>
	<ul>
		<li>
			Erstellen Sie immer einen Benutzer für die tägliche Arbeit. Wenn dieser Benutzer root-Zugang benötigt, dann fügen Sie
			diesen Benutzer zur Gruppe wheel hinzu. Dies erlaubt einem normalen benutzer "nach root zu su'en".
		</li>
		<li>
			Lassen Sie X oder irgendeine andere Benutzeranwendung als root laufen.
		</li>
		<li>
			Benutzen Sie immer absolute Pfadangaben, wenn Sie als root angemeldet sind. Sonst ist es möglich, root
			eine andere Anwendung ausführen zu lassen, als er denkt (wenn zum Beispiel jemand an PATH manipuliert hat und root ohne
			<c>su -</c> su'ed). Dann wird root den Pfad des Nutzers benutzen.
		</li>
		<li>
			Wenn ein Benutzer nur ein paar Kommandos anstatt von allen die root benutzen kann, dann überlegen Sie, vielleicht auf sudo zurückzugreifen -
			aber seien Sie vorsichtig damit.
		</li>
		<li>
			Verlassen Sie nie den Terminal, wenn root angemeldet ist!
		</li>
	</ul>
	<p>
		Gentoo hat einen allgemeinen Schutz gegen normale Benutzer, die versuchen su einzusetzen. Die Standardeinstellung von PAM besagt,
		dass ein Benutzer in der Gruppe wheel sein muss, um su benutzen zu dürfen.
	</p>
</body>
</section>

<section>
<title>Richtlinien</title>
<body>
	<section>
	<title>Warum Richtlinien benötigt werden</title>
	<body>
		<p>
			Es gibt verschiedene Gründe, weshalb Richtlinien benötigt werden.
		</p>
		<ul>
			<li>
				Sie können nicht behaupten ein sicheres Netzwerk zu haben, ohne jemals definiert zu haben, was sicher ist.
			</li>
			<li>
				Es ist fast unmöglich potientielle Angreifer zu erwischen, Netzwerkprobleme zu lösen, oder Prüfungen zu dirigieren
				ohne den Netzwerkverkehr abzuhören oder in private Home-Verzeichnisse zu sehen. Aber dieses Reinhören ohne
				Erlaubnis des Nutzers ist in den meisten Ländern illegal. Und da 60% aller Angriffe von innerhalb eines Unternehmens kommen ist
				es wichtig, dass Sie die Augen offen halten.
			</li>
			<li>
				Sie können von Ihren Anwendern nicht erwarten, dass sie sich Gedanken über Sicherheit machen, wenn Sie
				niemals erklärt haben warum es wichtig ist oder wie sie sich selbst und ihre Kollegen schützen sollten.
			</li>
			<li>
				Gute Richtlinien und Netzwerkdokumentation zahlt sich immer aus - egal wie.
			</li>
			<li>
				Die Polizei oder die Staatliche Kriminalbehörde kann Ihnen nicht helfen den Angreifer dingfest zu machen,
				wenn diese nicht wissen wie Ihre Netzwerkkonfiguration aussieht oder welche Dienste Sie anbieten.
			</li>
			<li>
				Was werden Sie tun, wenn es einen Angriff gab? Sie müssen definieren, was Sie tun würden und wen Sie
				informieren würden. Würden Sie bloss die Polizei oder ein CERT-Team bei jeder Gelegenheit anrufen?
				Die würden Sie nicht ernst nehmen.
			</li>
		</ul>

		<p>
			Dies sollte eigentlich darlegen, warum es wichtig ist, Richtlinien auf Systemen mit mehr als einem Benutzer
			festzulegen und warum es wichtig ist, die Anwender zu erziehen.
		</p>
		<p>
			Eine Richtlinie ist ein Dokument (oder mehrere Dokumente) mit Antworten auf die Fragen "wer", "wo", "warum" und "was".
			Jeder Anwender in Ihrem System/Netzwerk sollte es lesen, verstehen und unterschreiben. Es ist wichtig, daß Sie sich die
			Zeit nehmen den Anwendern beim Verstehen der Richtlinie helfen: dem Grund, weshalb diese Richtlinie unterschrieben werden muß und
			was passiert, wenn sie direkt gegen die Richtlinie verstossen (dies sollte in der Richtlinie aufgeführt sein). Dies
			sollte mindestens einmal im Jahr wiederholt werden, da sich die Richtlinie ändern kann, aber auch um die Anwender immer
			wieder aufs Neue daran zu erinnern.
		</p>
		<note>
			Erstellen Sie Richtlinien, die einfach zu lesen sind und sich klar und direkt zu jedem Thema äußern.
		</note>
		<p>
			Manche Teile einer Richtlinie können direkt im Betriebssystem unterstützt werden, manche nicht.
		</p>
	</body>
	</section>

	<section>
	<title>Sicherheitsrichtlinien</title>
	<body>
		<p>
			Eine Sicherheitsrichtlinie ist nichts anderes als ein Satz von Regeln der Ihre Netzwrk-/Rechnersicherheit sichern soll.
			Es ist eigentlich ein Dokument mit Informationen darüber, wie Computer, Netzwerk, Passwort, E-Mail und sogar die Anwender
			sich verhalten bzw. nicht verhalten sollen, was zu tun ist, wenn ein Angriff stattfand, wie die Maschinen (Arbeitsplatz/Server)
			zu installieren sind, Infrastruktur, usw.
		</p>
		<p>
			Eine Sicherheitsrichtlinie sollte mindestens die folgenden Punkte beinhalten:
		</p>
		<ul>
			<li>
				Akzeptable Anwendung
			</li>
			<ul>
  				<li>
					Bildschirmschoner
				</li>
  				<li>
					Behandlung von Kennwörtern
				</li>
  				<li>
					Herunterladen von Programmen
				</li>
  				<li>
					Wissen darüber, ob diese überwacht werden
				</li>
  				<li>
					Benutzung von Antiviren-Software
				</li>
  				<li>
					etc.
				</li>
			</ul>

			<li>
				Behandlung von sensitiven Daten (jegliche Schriftliche Form, Papier oder digital)
			</li>
			<ul>
  				<li>
					Sauberer Schreibtisch und verschlossene, vertrauliche Informationen
				</li>
  				<li>
					PC herunterfahren vorm Verlassen
				</li>
  				<li>
					Benutzung von Verschlüsselung
				</li>
  				<li>
					Behandlung von Schlüsseln für vertraute Mitarbeiter
				</li>
  				<li>
					Behandlung von vertraulichem Material auf Reisen
				</li>
			</ul>

			<li>
				Behandlung der Computerausstattung auf Reisen.
			</li>
			<ul>
    			<li>
					Behandlung des Laptops auf Reisen und bei Hotelaufenthalten.
				</li>
			</ul>
		</ul>

		<p>
			Die Richtlinie für die IT-Abteilung kann sich von der für die normalen Angestellten leicht unterscheiden.
		</p>
		<p>
			Die Sicherheitsrichtlinie kann riesig werden und wichtige Informationen können leicht vergessen gehen.
			Die Richtline für die IT-Abteilung kann Informationen enthalten, die gegenüber den normalen Benutzern
			als vertraulich gelten. Somit ist es sinnvoll, sich in kleinen Richtlinien fort zu bewegen: Richtlinie
			für akzeptable Bedienung, Richtlinie für Passwörter, für E-Mail und für Fernzugriff.
		</p>
		<p>
			Beispiele für Richtlinien können beim
			<uri link="http://www.sans.org/newlook/resources/policies/policies.htm">The SANS Security Policy Project</uri>.
			gefunden werden. Wenn Sie ein kleines Netzwerk haben und diese Richtlinie für zu gross halten, dann sollten sie einen
			Blick auf das
			<uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">RFC2196</uri> werfen, dass ein Sicherheitshandbuch darstellt
		</p>
	</body>
	</section>
</body>
</section>
</chapter>

-- Considerations before installation end --

-- Tightening the security after/during installation start --

<chapter>
<title>Die Sicherheit nach/während der Installation anziehen</title>
<section>
<title>/etc/make.conf</title>
<body>

<p>
Die make.conf-Datei enthält alle Optionen und Extra-Bibliotheken die Sie während der Abarbeitung von
Ebuilds benutzen möchten. In dieser Datei sollten Sie sicherstellen, daß das Ebuild jede nur erdenkliche
Sicherheitsbibliothek wie z.B. PAM (Pluggable Authentication Module), TCP Wrapper oder SSL unterstützt, wenn es
dies kann. Die globale USE-Variable sollte pam, tcpd und ssl enthalten.
</p>

<p>
Also fügen Sie etwas Ähnliches zu dem hier ein:
</p>

<pre caption="USE settings to be added">
USE="tcpd pam ssl"
</pre>

</body>
</section>

<section>
<title>GRUB/LILO Passwort</title>
<body>
<section>
<title>GRUB</title>
<body>

<p>
Grub unterstützt 2 verschiedene Wege für Passwortkontrolle in seiner Konfigurationsdatei(<path>/boot/grub/menu.1st</path>):
Einmal Normalen Text und einmal mit md5+salt Verschlüsselung.
</p>

<pre caption="/boot/grub/menu.lst">
timeout 5
password changeme
</pre>

<p>
Dies wird das Passwort <e>changeme</e> hinzufügen; wenn kein Passwort eingegeben ist, wird die Standard-Boot-Einstellung genommen.
</p>

<p>
Sollte ein md5-Passwort genommen werden, dann müssen Sie das Passwort ins Crypt-Format konvertieren (man crypt), daß
das selbe Format wie die Shadow-Datei hat. Zum beispiel könnte das verschlüsselte Passwort <e>changeme</e> so aussehen:
<e>$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</e>
</p>

<p>
Oder dies:
</p>

<pre caption="/boot/grub/menu.lst">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<warn>
Wenn Sie das hier testen, dann denken sie daran, den Zeitablauf festzulegen. Ansonsten werden Sie nicht fähig sein das System zu
starten, wenn das Kennwort nicht korrekt ist.
</warn>

<p>
Der Zeitablauf von 5 Sekunden wird sinnvoll, wenn das System von fern bedient wird und bei einem Neustart ohne Tastatureingaben auskommen muss.
Mehr Informationen über Grub-Passwörter können Sie über die Ausführung von <path>info grub</path> bekommen.
</p>

</body>
</section>

<section>
<title>LILO</title>
<body>

<p>
LILO unterstützt auch zwei Arten des Behandelns von Passwörtern : Global und Imagerelativ -- beide in Klartext.
</p>

<p>
Das globale wird am Anfang der Konfigurationsdatei gesetzt:
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
Im anderen Fall fügen Sie es einfach beim entsprechenden Image hinzu.
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
Wenn die <e>restricted</e>-Option nicht angegeben wurde, dann wird jedes Mal nach einem Passwort gefragt.
</p>

<p>
Um die Änderungen an lilo.conf zu übernehmen, müssen Sie <c>/sbin/lilo</c> ausführen.

</p>

</body>
</section>
</body>
</section>

<section>
<title>Einschränkung der Konsolenbenutzung.</title>
<body>
<p>
<path>/etc/securetty</path> enthält Terminaltypen die es Ihnen ermöglichen/erlauben festzulegen von
welchen TTY Geräten aus root sich einloggen darf.
</p>

<p>
Wir empfehlen, dass sie alle Zeilen bis auf vc/1 auskommentieren. Dies stellt sicher, dass sich root nur
einmal einloggen kann und nur an einem Terminal.
</p>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>

<section>
<title>Mehr Protokolle (logs)</title>
<body>

<p>
Zusätzliche Protokolle sollten hinzugefügt werden um Warnungen oder Fehler aufzuspüren, die vor
einem momentanen oder bereits durchgeführten Angriff warnen könnten. Angreifer beobachten ein
Netzwerk oder durchsuchen dies oft bevor sie angreifen.
</p>

<p>
Es ist auch unersetzlich, dass die Protokolldateien einfach zu lesen und zu verwalten sind.
</p>

<p>
Gentoo Linux gibt ihnen die Möglichkeit bei der Installation zwischen drei verschiedenen Protokollierungsprogrammen zu wählen.
</p>

<section>
<title>Syslogd</title>
<body>

<p>
Syslogd ist das gängigste Protokollierungsprogramm für Linux und Unix. Es beinhaltet keine Protokollrotation.
Diese Eigenschaft wird übernommen durch das Verwenden von <path>/usr/sbin/logrotate</path> in einem cron job
und korrekt konfigurierten Einstellungen in <path>/etc/logrotate.conf</path>. Wie oft die Protokollrotation
stattfinden sollte hängt von der Systembelastung ab.
</p>

<p>
Hier ist ein Beispiel wie man syslog konfigurieren kann
</p>

<pre caption="/etc/syslog.conf">
*.=debug                   /var/log/debug
*.err                      /var/log/syslog

#Benutzer, die die Meldung sehen sollten, wenn sie angemeldet sind
*.=alert                   root,<c>hier Ihr Benutzername</c>
*.=emerg                   root,<c>hier Ihr Benutzername</c>

mail.info,mail.notice      /var/log/maillog
kern.*                     /var/log/kern.log
daemon.info;daemon.notice  /var/log/daemon.log
cron.*                     /var/log/cron.log
mail.*                     /var/log/mail.log
user.*                     /var/log/user.log
uucp.*                     /var/log/uucp.log
*.*;auth,authpriv.none     /var/log/syslog

#Die Logdatei an zwei Orten unterbringen
authpriv.*;auth.*          /admin/auth.log
authpriv.*;auth.*          /var/log/secure

#Alles auf der Konsole schreiben
*.*                        /dev/tty12

#Oder einen fernen Logging-Server ansteuern
*.*                        @logserver
</pre>

<p>
Der Angreifer wird höchstwahrscheinlich versuchen seine Spuren zu verwischen indem er die Protokolldateien
bearbeitet oder löscht. Sie können es für den Angreifer schwerer machen indem sie das Protokoll an einen
oder mehrere Protokollserver auf verschiedenen Maschinen schicken.
</p>

<p>
Mehr Informationen über syslogd finden sie in der man page (<path>man syslog</path>)
</p>

</body>
</section>

<section>
<title>Metalog</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> von Frank Dennis bietet nicht die Möglichkeit
Protokolle an einen entfernten (remote) Server zu senden, aber es hat Vorteile im  Bereich der Performance
und der Protokollierungsflexibilität.
</p>

<p>
Es kann nach Programmnamen oder nach Einrichtung(facility?) protokollieren (wie syslogd) und beinhaltet
reguläre Ausdrucksübereinstimmung und die Möglichkeit Kommandos auszuführen. Sehr gut um handeln zu
können, wenn nötig.
</p>

<pre caption="/etc/metalog.conf">
maxsize  = 1000000
maxtime  = 86400
maxfiles = 7
minimum  = 7

Kernelnachrichten :

  facility = "kern"
  logdir   = "/var/log/kernel"

Auth-Nachrichten :
  facility = "auth"
  logdir   = "/var/log/auth"

Notfälle :
  facility = "emerg"
  command  = "/usr/local/sbin/pwdfail.sh"

Crond :

  program  = "crond"
  logdir   = "/var/log/crond"

Passwortfehler :

  regex    = "(password|login|authentication)\s+(fail|invalid)"
  regex    = "(failed|invalid)\s+(password|login|authentication)"
  regex    = "ILLEGAL ROOT LOGIN"
  logdir   = "/var/log/pwdfail"
  command  = "/usr/local/sbin/pwdfail.sh"

SSH Server :

  program  = "sshd"
  logdir   = "/var/log/sshd"

Mail :

  facility = "mail"
  logdir   = "/var/log/mail"

Snort:
  program   = "snort"
  command  = "/usr/local/sbin/pwdfail.sh"

Alles Wichtige :

  facility = "*"
  logdir   = "/var/log/everything"

Alles sehr Wichtige :

  facility = "*"
  logdir   = "/var/log/critical"

</pre>

<p>
Dies ist im Prinzip eine Standardkonfiguration - mit einigen Modifikationen, z.B. einem
Minimum-Protokollierungslevel von 7 (dies bedeutet, dass alles protokolliert wird).
</p>

<p>
pwdfail.sh für postfix.
</p>

<pre caption = "postfix' pwdfail.sh">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
pwdfail.sh für qmail.
</p>

<pre caption = "qmail's pwdfail.sh">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Mehr Informationen finden sie auf der <uri link="http://metalog.sourceforge.net">Metalog</uri> Webseite.
</p>


</body>
</section>
<section>

<title>Syslog-ng</title>
<body>

<p>
Syslog-ng enthält einige derselben Funktionen wie Syslog und Metalog mit einem kleinen Unterschied. Es ermöglicht die Filterung von Nachrichten basierend auf Level und Inhalt (wie Metalog), bietet entferntes protokollieren (wie syslog) und kann Protokolle von syslogd verarbeiten. Sogar Streams von Solaris, schreiben an ein TTY, Ausführen von Programmen und es kann als Protokollierungsserver benutzt werden.
Grundlegend ist dies das Beste aus beiden Prtokollierern kombiniert mit einer erweiterten Konfiguration.
</p>

<p>
Eine klassische, leicht modifizierte Konfigurationsdatei.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#Quelle von der das Log gelesen werden soll
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#Ziele festlegen
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#Filter erstellen
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#Filter und Ziele verbinden
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#Standard-Log
log { source(src); destination(console_all); };
</pre>

<p>
Sehr einfach zu konfigurieren, aber es ist auch sehr einfach etwas zu übersehen, da die Konfigurationsdatei
riesig ist. Der Author verspricht zudem noch einige zusätzliche Funktionen wie Verschlüsselung, Authentifizierung,
Komprimierung und MAC (Mandatory Acces Control) Kontrolle. Mit diesen Optionen wird es perfekt sein für
Netzwerkprotokollierung, da der Angreifer die Protokolle nicht ausspionieren kann.
</p>

<p>
Syslog-ng hat auch noch andere Vorteile, es muss nicht als root laufen!
</p>

</body>
</section>
</body>
</section>

<section>
<title>Partitionen mounten</title>
<body>

<p>
Mountet man eine ext2, ext3 oder eine reiserfs Partition, so gibt es mehrere Optionen die man in
<path>/etc/fstab</path> einfügen kann. Diese Optionen sind:
</p>

<ul>

<li>
nosuid - Ignoriert das SUID bit und behandelt es einfach wie eine normale Datei.
</li>

<li>
noexec - Verhindert das Ausführen von Dateien von dieser Partition.
</li>

<li>
nodev - Ignoriert Geräte.
</li>
</ul>

<p>
Leider können diese Einstellungen leicht umgangen werden indem man einen nicht-direkten Pfad ausführt.
Jedoch wenn man /tmp auf noexec setzt stoppt das etwa 99% aller Script-Kiddies, da deren Exploits so
gestaltet sind, dass sie direkt von /tmp ausgeführt werden.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>
<warn>Setzt man <path>/tmp</path> in noexec Modus, kann dies dazu führen, dass einige Scripts nicht richtig asugeführt werden.</warn>
<note>Plattenquoten werden in einem anderen Kapitel beschrieben</note>

<p>
Beachten sie, dass ich <path>/var</path> weder in noexec noch in nosuid Modus setze, obwohl Dateien von diesem Mountpunkt
normalerweise niemals ausgeführt werden. Der Grund dafür ist, dass qmail in <path>/var/qmail</path> installiert ist
und berechtigt sein muss eine suid-Datei auszuführen und auf sie zuzugreifen. Ich setze <path>/usr</path> in read-only
Modus, da ich hier nichts verändere solange ich Gentoo nicht aktualisiere. Dann mounte ich das Dateisystem erneut in
read-write Modus, aktualisiere und mounte dann erneut in read-only.
</p>

<note> Selbst wenn sie qmail nicht benutzen, braucht Gentoo trotzdem noch die Ausführberechtigung in <path>/var/tmp</path>,
da dort ebuilds hergestellt werden. Jedoch kann hierfür ein alternativer Pfad eingerichtet werden, wenn Sie darauf bestehen
<path>/var</path> in noexec Modus zu betreiben.
</note>

</body>
</section>

<section>
<title>Einschränkungen für Benutzer/Gruppen </title>
<body>

<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
Die Kontrolle von Ressourcenbegrenzungen kann sehr effektiv sein, wenn es darum geht eine lokale DoS Attacke zu
verhindern oder bei der Handhabung von maximal erlaubten Logins für eine Gruppe oder einen Benutzer.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
Wenn Sie dabei sind den Wert von nproc oder maxlogins gleich 0 zu setzen, sollten sie diesen Benutzer vielleicht
lieber löschen. Das Beispiel oben setzt die Einstellungen für die Gruppe "dev" für Prozesse, Kerndateien und maximale
Logins. Der Rest erhält einen Standardwert.
</p>
<note><path>/etc/security/limits.conf</path> ist Teil des PAM Paketes und wir nur angewendet auf Pakete die PAM benutzen.
</note>


</body>
</section>

<section>
<title>/etc/limits</title>
<body>
<p>
Limits sind recht ähnlich zur Limit-Datei in <path>/etc/security/limits.conf</path>. Der einzige Unterschied ist das
Format und daß dies nur auf Benutzern oder Wild-Cards (aber keinen Gruppen) funktioniert. Werfen wir einen Blick
auf die Konfiguration:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Hier setzen wir die Standardeinstellungen und eine spezielle Einstellung für den Anwender <e>kn</e>. Limits sind ein Teil
des Shadow-Paketes und betreffen nur das Shadow-Login-Programm. Es ist nicht notwendig irgendwelche Beschränkungen in dieser
Datei zu setzen, wenn Sie die PAM-Einstellung in /etc/make.conf vorgenommen haben und PAM vollständig konfiguriert haben.
</p>

</body>
</section>
<section>

<title>Quotas</title>
<body>

<p>
Die Anwendung von Quotas auf einem Dateisystem verhindert, daß Anwender den Datenträger mit Ihren Daten überfüllen oder
es verhindert das Schreiben für Anwender überhaupt. Die Kernel-Option wird bei der Kernelkonfiguration unter
<c>File systems->Quota support</c> aktiviert. Nehmen Sie die folgende Einstellung vor, kompilieren Sie das Kernel neu
und starten Sie mit diesem Ihren Computer neu.
</p>

<pre caption="Installing quota">
# <i>emerge quota</i>
</pre>

<p>
Passen Sie Ihre <path>/etc/fstab</path> an, indem Sie usrquota und grpquota bei den Partitionen hinzufügen,
für die Sie die Nutzungsbeschränkung festlegen wollen.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Auf jeder Partition auf der Sie Quotas aktiviert haben erstellen Sie nun die Quota-Dateien (quota.user und quota.group) und setzen Sie sie in die
Wurzel der Partition
</p>

<pre caption="Erstellen der Quota-Dateien">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
Dieser Schritt muss auf jeder Partition durchgeführt werden, auf der Quotas aktiviert wurden.
Nachdem Sie die Quota-Dateien erstellt und konfiguriert haben, muss ein Initskript erstellt werden, dass
die Quotas jedesmal beim Booten aktiviert. Kopieren Sie das folgende Skript und erstellen Sie damit eine
Datei namens <path>/etc/init.d/quotas</path>. Erstellen Sie einfach die Datei (wenn sie noch nicht existiert)
und machen Sie es ausführbar.
</p>

<pre caption="/etc/init.d/quotas">
#!/sbin/runscript

depend() {
	need localmount
}

start() {
        if [ -x /sbin/quotacheck ]
        then
               ebegin "Pruefe Quotas. Dies kann etwas dauern."
               /sbin/quotacheck -avug
               eend $?
        fi
        if [ -x /sbin/quotaon ]
        then
               ebegin "Schalte Quota an."
               /sbin/quotaon -avug
               eend $?
        fi
}

stop() {
        if [ -x /sbin/quotaon ]
        then
	       ebegin "Schalte Quota aus."
               /sbin/quotaoff
	       eend $?
        fi
}
</pre>

<p>
Fügen Sie es mittels <c>rc-update add quotas default</c> dem Runlevel hinzu und fügen Sie ausserdem
quotacheck (crontab -e) der Crontabelle hinzu, sodass es einmal in der Woche ausgeführt wird : <c>0 3 * * 0 /sbin/quotacheck -avug</c>.
</p>

<p>
Nachdem Sie den Rechner neu gestartet haben, ist es an der Zeit, die Quotas für die Benutzer und Gruppen festzulegen.
<c>edquota -u kn</c> wird den in $EDITOR festgelegten Editor starten (Standard ist nano) damit Sie die Quotas des
Benutzers kn bearbeiten können. -g wird genau das Selbe, allerdings für Gruppen machen.
</p>

<pre caption="Bearbeiten der Quotas für den Benutzer kn">
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Für weitere Informationen lesen Sie bitte <e>man edquota</e> oder <uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Das Quota Mini-Howto</uri>
</p>

</body>
</section>

<section>
<title>/etc/login.defs</title>
<body>

<p>
Wenn die Richtlinie besagt, dass die Anwender jede Woche ihr Passwort ändern müssen, dann setzen Sie die Variable PASS_MAX_DAYS auf 14
und PASS_WARN_AGE auf 7. Es wird ausserdem empfohlen, dass Sie alternde Passwörter benutzen, da Brute-Force Angriffe jedes Passwort
finden können - alles nur eine Frage der zeit. Wir empfehlen ausserdem, dass Sie LOG_OK_LOGINS auf yes setzen.
</p>

</body>
</section>

<section>
<title>/etc/login.access</title>
<body>
<p>
Die login.access ist auch ein Teil des Shadow-Paketes, dass eine Login Zugangs-Kontrolltabelle anbietet. Die Tabelle wird benutzt um
zu kontrollieren, wer und wer nicht einloggen darf, basierend auf dem Benutzernamen, dem Gruppennamen oder dem Hostnamen von dem der
Versuch gestartet wird. Normalerweise sind alle Anwender des systems berechtigt sich anzumelden; aus diesem Grunde ist die Datei nur
mit Kommentaren und Beispielen gefüllt. Je nachdem ob Sie Ihren Server oder Ihren Arbeitsplatzrechner schützen empfehlen wir die Datei
so anzupassen, das niemand anderes als Sie selbst (also der Administrator) Zugang zur Konsole bekommt.
</p>
<note>Diese Einstellungen sind nicht für root anwendbar</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<warn>
Seien Sie vorsichtig bei der Bearbeitung der Datei. Wenn Sie nicht aufpassen, dann können Sie sich aussperren!
</warn>
<note>
---------------------------
Diese Einstellungen wirken sich nicht auf SSH aus, da SSH /bin/login normalerweise nicht ausführt. Dies kann ermöglicht werden durch die Benutzung von "UseLogin yes" in <path>/etc/ssh/sshd_config</path>. Das führt dazu, dass SSH login benutzt und die Einstellungen benutzt werden.
</note>

<p>
Dies erstellt Loginzugriff so dass Mitglieder von wheel sich an der Konsole einloggen können oder wenn ihre Quelle die gentoo.org Domäne ist.
Vielleicht ein wenig zu paranoid, aber sicher ist sicher.
</p>

</body>
</section>

<section>
<title>Dateiberechtigungen.</title>
<body>

<section>
<title>Von allen lesbar (world).</title>
<body>

<p>
Normale Benutzer sollten zu Konfigurationsdateien oder Passwörtern keinen Zugang haben. Ein Angreifer kann Passwörter aus einer Datenbank oder von einer Webseite stehlen und verunstalten oder noch schlimmer: Daten löschen. Deswegen ist es notwendig, dass die Berechtigungen korrekt gesetzt sind. Wenn Sie sicher sind, dass eine Datei nur von root benutzt wird, geben Sie ihr die Berechtigung 0600 und ordnen Sie diese mit chown dem richtigen Benutzer zu.
</p>

</body>
</section>

<section>
<title>Welt/Gruppen-Schreibbar.</title>
<body>

<pre caption="Auffinen von Dateien und Verzeichnissen die von allen schreibar sind">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Dies schafft eine riesige Datei mit Berechtigungen von allen Dateien die entweder Schreibberechtigungen für alle oder eine Gruppe haben. Überprüfen Sie die Berechtigungen und eliminieren Sie die für alle schreibbaren Dateien durch das Ausführen von <path>/bin/chmod o-w</path> für die Dateien.
</p>

</body>
</section>

<section>
<title>SUID/SGID Dateien</title>
<body>

<p>
SUID/SGID Dateien (Dateien bei denen das superuser bit gestzt wurde) ist ein Weg für normale Benutzer Dinge zu tun die normalerweise nur root darf. Diese Dateien können zu lokalen root-Brüchen führen (wenn sie Sicherheitslöcher enthalten), da so eine Datei mit root Berechtigungen ausgeführt wird. Diese Dateien sind gefährlich und sollten unter allen Umständen vermieden werden. Wenn Sie die Dateien nicht benutzen. führen sie chmod 0 aus oder entfernen sie das Paket (unmerge) aus dem sie stammen (überprüfen sie das Paket mit qpkg -f. Wenn sie es nicht längst installiert haben tun sie dies mit <c>emerge gentoolkit</c>). Ansonsten schalten sie das siud bit einfach mit chmod-s ab.
</p>

<pre caption="Auffinden von setuid Dateien">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
Dies erzeugt eine Datei mit einer Liste aller SUID/SGID Dateien.
</p>

<pre caption="Liste der setuid binären Dateien">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Standardmäßig hat Gentoo Linux nicht viele SUID Dateien (es hängt davon, was Sie installiert haben), aber Sie könnten eine Liste wie die obrige erhalten. Viele dieser Befehle sollten nicht von normalen Benutzern bentutzt werden, sondern nur von root. Schalten sie das suid bit bei ping, mount, umount, chfn, chsh, newgrp, suidperl, pt_chown und traceroute aus. Sie tun dies mit dem Befehl <c>chmod -s</c> bei jeder einzelnen Datei. Entfernen Sie das bit nicht von su, qmail-queue oder unix_chkpwd. Dies würde dazu führen, dass Sie nicht mehr su benutzen und mail empfangen könnten. Durch entfernen des bits entfernen Sie die Möglichkeit, dass ein normaler User (oder Angreifer) root Zugriff durch eine dieser Dateien erlangen kann.
</p>

<p>
Die einzigen SUID Dateien die ich auf meinem System habe sind su, passwd, gpasswd, qmail-queue, unix_chkpwd und pwdb_chkpwd. Aber wenn sie X benutzen, könnten sie einige mehr haben, denn X benötigt diesen Zugriff.
</p>

</body>
</section>


</body>
</section>


<section>
<title>PAM (Pluggable Authentication Modules)</title>
<body>

<p>
PAM ist eine Sammlung von shared libraries die eine Alternative darstellen für Authetifizierungen in Programmen. Die PAM Einstellungen von Gentoo Linux sind relativ vernünftig, aber es gibt immer Platz für Verbesserungen.
</p>
<note>Dieses Kapitel wird keine Auswirkungen haben, wenn sie PAM nicht in Ihren USE Optionen in <path>/etc/make.conf</path> angegeben haben.
</note>

<p>Installieren von cracklib</p>

<pre caption="Installieren von cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_pwdb.so shadow nullok
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_pwdb.so md5 use_authtok
session	 required pam_pwdb.so
</pre>

<p>
Dies fügt die cracklib hinzu, welche sicherstellt, dass der Benutzer eine minimale Passwortlänge von 8 Zeichen benutzt; Bestehend aus mindestens 2 Zahlen, 2 Unterschiedlichen und es müssen mindestens 3 Zeichen anders sein als beim letzten Passwort. Dies zwingt den Benutzer ein gutes Passwort zu wählen (Passwortrichtlinien). In der Dokumentation von <uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri> finden Sie weitere Optionen.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_pwdb.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_pwdb.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_pwdb.so shadow md5
session	 required pam_pwdb.so
session	 required pam_limits.so
</pre>

<p>
Jeder andere Dienst der nicht mit einer PAM Datei in <path>/etc/pam.d</path> konfiguriert ist wird die "andere" Regel benutzen. Die Standardeinstellung sind auf Verweigern gesetzt, so wie es sein sollte. Jedoch habe ich gerne viele Protokolle und deswegen habe ich pam_warn.so hinzugefügt. Die letzte Konfiguration ist pam_limits welche von <path>/etc/security/limits.conf</path> kontrolliert wird. Siehe das passende Kapitel hierzu.
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>

<section>
<title>TCP Wrappers</title>
<body>

<p>
Ist ein Weg um Zugang zu kontrollieren für Dienste die normalerweise von inetd ausgeführt werden (welches Gentoo nicht hat) aber es kann auch von xinetd und anderen Diensten benutzt werden.
</p>
<note>
Use in make.conf sollte tcpd beinhalten und der Dienst sollte tcpd in seinem Serverargument (in xinetd) asugeführt werden. </note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Wie Sie sehen können ist das Format sehr ähnlich dem in <path>/etc/login.access</path>. Tcpd unterstützt einen spezifischen Dienst und sie arbeiten nicht im selben Gebiet von Sicherheit. Diese Einstellungen gelten nur für Dienste die TCP Wrapper benutzen.
</p>

<p>
Es ist auch möglich Befehle auszuführen wenn auf einen Dienst zugegriffen wird (kann benutzt werden wenn Weiterleiten für Benutzer die sich einwählen aktiviert wird) aber es nicht empfohlen, da Menschen dazu neigen mehr Probleme zu schaffen als sie versuchen zu beheben. Ein Beispiel könnte sein, dass sie ein Script konfigurieren um email zu senden jedes mal wenn jemand die deny-Regel trifft, aber ein Angreifer könnte so eine DoS Attacke ausführen indem er darauf weiter zugreift. Dies schafft viel I/O und viele mails, deswegen tun Sie es nicht! Lesen Sie <c>man 5 hosts_access</c> für weitere Informationen.
</p>

</body>
</section>


</body>
</section>
</chapter>

-- Verstärkung der Sicherheit nach/während dem Installationsende --

-- Kernel Sicherheitsstart --

<chapter>
<title>Kernelsicherheit</title>

<section>
<title>Funktionsentfernung</title>
<body>

<p>
Eine grundlegende Regel ist die Entfernung von allem das sie nicht brauchen. Dies schafft einen kleinen Kernel, entfernt aber die Verwundbarkeiten die in Treibern oder anderen Eigenschaften liegen können.
</p>

<p>
Ziehen Sie auch in betracht loadable module support(=ladbare-Modulunterstützung) auszuschalten. Auch wenn es möglich ist Module ohne diese Eigenschaft hinzuzufügen (root kits), wird es doch schwerer für den normalen Angreifer root kits über Kernelmodule zu installieren.
</p>

</body>
</section>

<section>
<title>/proc (kernel flags)</title>
<body>

<p>
Viele Kernel Parameter können durch das /proc Dateisystem verändert werden, oder durch die Benutzung von sysct1.
</p>

<p>
Um dynamisch Kernelparameter und -variablen sofort zu ändern benötigen Sie CONFIG_SYSCTL in Ihrem Kernel. Die ist voreingestellt im Standard 2.4 Kernel.
</p>

<pre caption="Entfernen von ping-Paketen">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Dies sperrt icmp Typ 0 (auch bekannt als Ping) Pakete. Der Grund hierfür ist, dass icmp Nutzlast mit anderen Informationen beinhalten kann als Sie denken. Administratoren benutzen Ping als Diagnoseprogramm und beschweren sich oft wenn sie Ping nicht benutzen können. Es gibt keinen Grund für einen Außenstehenden die Möglichkeit zu haben Ping zu benutzen, aber ab und zu kann es hilfreich für Eingeweihte sein diese Möglichkeit zu haben. Das Problem kann dadurch gelöst werden indem man icmp type 0 in der Firewall deaktiviert.
</p>

<pre caption="Ignorieren von broadcast-Pings">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Dies sperrt Antworten auf Anfragen.
</p>

<p>
Sie wollen schliesslich nicht ein Schlumpfverstärker werden. Schlumpfverstärker oder X-mass trees ist eine Methode die es einem Angreifer erlaubt einen moderaten Teil von Traffic zu senden und geradezu eine Explosion von Traffic zu verursachen am beabsichtigten Ziel.
</p>

<pre caption="Sperren von source routed Paketen">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Sperrt source routed Pakete
</p>

<p>
Akzeptieren sie keine source routed Pakete. Angreifer können source routing benutzen um Traffic zu erzeugen der vorgibt aus dem Netzwerk zu kommen, jedoch weitergeleitet wurde den Pfad von dem es ursprünglich kam. Sperren sie Source Routing denn es wird selten für legitime Zwecke genutzt.
</p>

<pre caption="Sperren von Umleitungsakzeptanz">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
Sperren Sie ICMP Umleitungsakzeptanz. ICMP Umleitungen können benutzt werden um Ihre routing tables zu verändern, möglicherweise zu einem schlimmen Ende.
</p>

<pre caption="Schutz gegen bad error messages">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Schalten sie den Schutz gegen bad error messages ein.
</p>

<pre caption="Ermöglichen von rückwärtiger Pfadfilterung">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>
Wenn Sie  IP forwarding aktivieren, werden Sie auch dieses Resultat erhalten.
</note>

<p>
Stellen Sie rückwärtiger Pfadfilterung (reverse path filtering) an. Dies hilft dabei, dass Pakete legitime Quelladressen benutzen, durch automatisches Ablehnen von eingehenden Paketen wenn der Eintrag in den routing tables für die Quelladresse nicht übereinstimmt mit der Netzwerkschnittstelle von der sie kommen. Dies hat Sicherheitsvorteile, weil es verhinder IP spoofing <c> jedoch kann es ein Problem sein, wenn Sie asymmetrisches routen verwenden </c> (Pakete von Ihnen an einen Host nehmen einen anderen Pfad als Pakete von diesem Host zu Ihnen) oder wenn Sie an einem nicht-routenden Host arbeiten, welcher verschiedene IP-Adressen an verschiedenen Schnittstellen hat.
</p>

<pre caption="Protokollieren aller spoofed, source routed und umgeleiteten Pakete">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Protokollieren von spoofed, source routed und umgeleiteten Pakete.
</p>

<pre caption="Aktivieren von IP forwarding">
# <i>/bin/echo "0" > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Stellen Sie sicher, dass IP forwarding ausgeschaltet ist. Wir wollen es nur für einen multi-homed Host.
</p>

<p>Alle diese Einstellungen werden zurückgesetzt wenn die Maschine neu gestartet wird. Daher schlage ich vor, dass Sie folgendes Script zum run level hinzufügen und es ausführbar machen.
</p>

<pre caption="/etc/init.d/procparam">
#!/sbin/runscript

depend() {
 before *
}

start() {
 ebegin "Setting /proc options."
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
 /bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
 /bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
 for i in /proc/sys/net/ipv4/conf/*; do
   /bin/echo "1" > $i/rp_filter
 done
 /bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
 /bin/echo "0" > /proc/sys/net/ipv4/ip_forward
 eend 0
}
</pre>

<p>Fügen Sie es zum run level dazu: <c>rc-update add procparam default</c>.</p>

</body>
</section>

<section>
<title>Kernel patches</title>
<body>
<section>
<title>Grsecurity</title>
<body>

<p>
Der Patch von <uri link="http://grsecurity.net">Grsecurity</uri> ist Standard im Gentoo Kernel aber per Voreinstellung deaktiviert. So aktivieren Sie ihn:
</p>

<p>
Konfigurieren Sie Ihren Kernel wie Sie normalerweise würden und dann konfigurieren Sie die Grsecurity Option:
(wählen sie customized) und stellen sie folgende Optionen ein:
</p>

<ul>
<li>Buffer Overflow Protection</li>
<ul>
  <li>Openwall non-executable stack</li>
  <li>Gcc trampoline support</li>
</ul>

<li>Filesystem Protections</li>
<ul>
  <li>Proc restrictions</li>
  <li>Linking restrictions</li>
  <li>Secure file descriptors</li>
  <li>Chroot jail restrictions (aktivieren sie alle Optionen unterhalb dieser)</li>
</ul>

<li>Kernel Auditing</li>
<ul>
  <li>Log execs within chroot</li>
  <li>(Un)Mount logging</li>
  <li>Signal logging</li>
  <li>Fork failure logging</li>
  <li>Log set*ids to root</li>
  <li>Time change logging</li>
</ul>

<li>Executable Protections</li>
<ul>
  <li>Dmesg restriction</li>
  <li>Randomized PIDs</li>
  <li>Altered default IPC permissions (kann verhindern, dass einige Programme korrekt ausgeführt werden)</li>
  <li>Restricted ptrace</li>
</ul>

<li>Network Protections</li>
<ul>
  <li>Randomized IP IDs</li>
  <li>Randomized TCP source ports</li>
  <li>Altered Ping IDs</li>
  <li>Randomized TTL</li>
</ul>
<li>Miscellaneous Features</li>
<ul>
  <li>BSD-style coredumps (erzeugt coredumps wie core.named)</li>
</ul>

</ul>

<p>
Jetzt kompilieren und installieren sie ihren Kernel mit verbesserter Sicherheit.
</p>

</body>
</section>

<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> ist ein Patch der Verschlüsselung zum existierenden Kernel hinzufügt. Durch patchen des Kernels erhalten Sie neue Optionen wie: Kryptrographische Chiffrierung, Zusammenfassungsalgorithmen und Kryptrographische-Schleifenfilter.
</p>
<warn>Der Kerneli Patch ist momentan nicht in einer stabilen Version für den neuesten Kernel, also Vorsicht beim Gebrauch.
</warn>

</body>
</section>

<section>
<title>Andere Kernel Patches</title>
<body>

<ul>
  <li><uri link="http://www.openwall.com">The OpenWall Project</uri> (nicht für 2.4 Kernel)</li>
  <li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
  <li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
  <li><uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri></li>
  <li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
Und es gibt wahrscheinlich vieles mehr...
</p>

</body>
</section>

</body>
</section>

</chapter>

-- Kernelsicherheit Ende --

-- Sichern von Diensten Start --

<chapter>
<title>Sichern von Diensten</title>

<section>
<title>Benutzung von xinetd</title>
<body>
<p>
xinetd ist ein Ersatz für inetd (welches Gentoo nicht hat), der Internet-Dienst-Daemon. Er unterstützt Zugriffskontrolle basierend auf den Adressen der entfernten Hosts und der Zugriffszeit. Es beinhaltet auch ausführliche Protokollfähigkeiten, inklusive Serverstartzeit, Adresse des entfernten Hosts, entfernter Benutzername, Serverlaufzeit und geforderte Abläufe.
</p>

<p>
Wie bei allen anderen Diensten ist es wichtig eine gute Standardkonfiguartion zu haben. Da aber xinetd von root benutzt wird und Protokolle unterstützt, von denen Sie möglicherweise die Funktionsweise nicht verstehen, raten wir Ihnen es nicht zu benutzen. Wenn Sie es aber doch benutzen wollen, fügen Sie so mehr Sicherheit hinzu:
</p>

<pre caption="Installieren von xinetd">
# <i>emerge xinetd tcpd</i>
</pre>

<p>
Ergänzen Sie die Konfigurationsdatei um:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# Dies konfiguriert pserver (cvs) durch xinetd mit den folgenden Einstellungen:
# maximal 10 Instanzen (10 Verbindungen gleichzeitig)
# Begrenzung von pserver auf tcp
# benutzen des Benutzer-cvs um diesen Dienst laufen zu lassen
# Anbinden der Schnittstelle an nur 1 IP
# Zulassen von Zugriff von 10.0.0.*
# Begrenzung der Zeit in der Entwickler auf das cvs
# zugreifen können von 08Uhr bis 17Uhr
# Benutzung von tcpd wrappers (Zugriffskontrolle kontrolliert durch 
# <path>/etc/hosts.allow</path> und <path>/etc/hosts.deny</path>)
# max_load ist an der Maschine auf 1.0 gesetzt
# die disable flag (sperren) steht auf nein, aber ich bevorzuge sie zu 
# haben, für den Fall das es gesperrt werden sollte
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
Für mehr Informationen lesen Sie  <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>SSH</title>
<body>

<p>
Die einzige Sicherheitsverstärkung die OpenSSH benötigt ist das benutzen einer stärkeren Verschlüsselung basierend auf Public Key Verschlüsselung. Zu viele Seiten (wie <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> und <uri>http://www.apache.org</uri>) haben unter unauthorisiertem Eindringen in ihre Systeme gelitten wegen Passwortlecks oder schlechten Passwörtern.
</p>

<pre caption="/etc/ssh/sshd_config">
#Aktivieren Sie nur Version 2
Protocol 2

#Kein direkter root Zugriff
PermitRootLogin no

#Benutzung von RSA Schlüsselauthentifizierung
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# Sperren von .rhost Dateien und normaler Passwordauthentifizierung
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

#Niemand außer Mitgliedern von wheel oder admin sollte Zugriff
AllowGroups wheel admin

#Und 2 Benutzer
AllowUsers kn bs

#Hinzufügen des Protokollierungslevels
SyslogFacility AUTH
LogLevel INFO

#bind
ListenAddress 127.0.0.1
</pre>

<p>
Jetzt ist das einzige was Ihre Benutzer mache müssen einen Schlüssel erstellen (auf ihrer Maschine von der sie sich einloggen wollen) mit folgendem Befehl:
</p>

<pre caption="Erstellen eines RSA Schlüsselpaares">
# <i>/usr/bin/ssh-keygen -t rsa</i>
</pre>

<p>
Tippen Sie einen Passsatz (auch Mantra genannt) ein:
</p>

<pre caption="Ausgabe von ssh-keygen">
Generierung des öffentlichen/privaten rsa Schlüsselpaares.
Geben sie den Dateinamen ein unter dem der Schlüssel gespeichert wird (/home/kn/.ssh/id_rsa):<c>[Enter drücken]</c>
Verzeichnis erstellt '/home/kn/.ssh'.
Passsatz eingeben (leer für keinen Passsatz): <c>[Passsatz eingeben]</c>
Denselben Passsatz erneut eingeben: <c>[Erneut Passsatz eingeben]</c>
Ihre Identifikation wurde in /home/kn/.ssh/id_rsa gespeichert.
Ihr öffentlicher Schlüssel wurde in /home/kn/.ssh/id_rsa.pub gespeichert.
Der Fingerabdruck des Schlüssels ist: 
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
Dies fügt zwei Dateien zu Ihrem <path>~/.ssh/</path> Verzeichnis mit den Namen id_rsa und id_rsa.pub hinzu. Die Datei id_rsa ist Ihr privater Schlüssel und sollte von anderen Leuten außer Ihnen ferngehalten werden. Die andere Datei id_rsa.pub soll an jeden Server verteilt werden zu dem Sie Zugriff haben. Fügen Sie den Schlüssel in das home Verzeichnis des Benutzers in <path>~/.ssh/authorized_keys</path> ein, so sollte der Benutzer die Möglichkeit haben sich einzuloggen.
</p>

<p>Ihre Benutzer sollten diesen privaten Schlüssel gut verwahren. Packen Sie es auf ein Medium, dass sie immer mit sich tragen oder lassen Sie es auf ihrer Workstation (fügen Sie dies in die <uri link="#doc_chap2">Passwort</uri>richtlinien ein).
</p>

<p>Mehr über <uri link="http://www.openssh.org">OpenSSH</uri> finden Sie auf der ihrer Webseite.</p>

</body>
</section>

<section>
<title>Securing X</title>
<body>

<p>
XFree ist von Haus aus als Xserver konfiguriert. Dies kann gefährlich sein, denn X benutzt unverschlüsselte
TCP-Verbindungen und wartet auf xclients. Wenn Sie diesen Dienst nicht brauchen, dann deaktivieren Sie ihn!.
Aber wenn Sie Ihren Arbeitsplatz als Xserver betreiben, dann benutzen Sie das Kommando <path>/usr/X11R6/bin/xhost</path>
nur mit äußerster Vorsicht. Dieses Kommando erlaubt Clients von anderen Rechnern sich mit Ihrer Anzeige zu verbinden
und diese auch zu nutzen. Dies kann sinnvoll sein, wenn Sie eine X-Anwendung von einem anderen Rechner brauchen und die
einzige Verbindung zwischen den Rechnern ein Netzwerk ist. Die Syntax lautet <path>/usr/X11R6/bin/xhost +hostname</path>.
</p>
<warn>
Benutzen Sie nie das xhost + feature! Dies wird jedem Client erlauben sich mit Ihrem X zu Verbinden und dieses unter
Kontrolle bringen. Wenn ein Angreifer Zugang zu Ihrem X erlangt, dann kann er Ihre Tastatureingaben überwachen und
Kontrolle über Ihren Desktop erlangen.
</warn>

<p>
Eine sichere Lösung ist dieses Feature vollständig zu deaktivieren indem Sie X mit <c>startx -- -nolisten</c> tcp
oder es auf Dauer über eine entsprechende Einstellung in der Konfigurationsdatei; ändern Sie die Zeile:
</p>
<pre caption="/usr/X11R6/bin/startx">
defaultserverargs=""
</pre>

<p> zu </p>
<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Wenn Sie einen grafischen Login-Manager benutzen, dann brauchen Sie einen anderen Ansatz.
</p>

<p>gdm (Gnome Display Manager)</p>

<p>Änderung:</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X
</pre>
<p>
zu
</p>
<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>xdm (X Display Manager) und kdm (Kde Display Manager)</p>

<p>Änderung</p>
<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X
</pre>

<p>zu</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp
</pre>

</body>
</section>

<section>
<title>Druckdienste</title>
<body>

<section>
<title>Lpd</title>
<body>
<p>
Muss noch geschrieben wernden
</p>
</body>
</section>

<section>
<title>Pdq</title>
<body>

<p>http://pdq.sourceforge.net/</p>

<p>
Muss noch geschrieben werden
</p>

</body>
</section>

</body>
</section>



<section>
<title>FTP</title>
<body>
<p>
FTP (File Transfer Protocol) ist im Allgemeinen eine schlechte Idee. Es benutzt unverschlüsselte Daten, lauscht auf zwei Ports
(normalerweise 20 und 21), unterstützt anonyme Anwender und ist etwas, nachdem Angreifer gerne zuerst schauen (um warez zu verteilen).
Wenn möglich benutzen Sie bitte sftpd oder http, denn das ftp-Protokoll enthält einige Sicherheitslücken. Wenn dies nicht möglich sein
sollte, dann sichern Sie Ihre Dienste so gut wie nur möglich und bereiten Sie sich vor.
</p>

<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd ist ein Abkömmling des originalen trollftpd. Für mehr Sicherheit und Funktionalität wurde es von Frank Dennis modifiziert.
</p>

<p>
Benutzen Sie virtuelle Benutzer (niemals Systemkonten) indem Sie die AUTH-Option aktivieren. Setzen Sie diese auf -lpuredb:/etc/pureftpd.pdb
und erstellen Sie Ihre Benutzer mittels <path>/usr/bin/pure-pw</path>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
## Anzahl der gleichzeitigen Verbindungen - insgesamt und je IP ##
MAX_CONN="-c 30"
MAX_CONN_IP="-C 10"

## Keine Uploads erlauben, wenn die Partition voller als dieser Wert hier ist##
DISK_FULL="-k 90%"

AUTH="-lpuredb:/etc/pureftpd.pdb"

## Diverse andere ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Desweiteren konfigurieren Sie die MISC_OTHER-Einstellung so, dass Folgendes verboten ist: keine Anonyma (-E)
und chroot auf jeden (-A). Benutzer können keine Dateien lesen oder schreiben, die mit einem . (Punkt) beginnen (-X),
maximale Leerlaufzeit (-I), Rekursion begrenzen (-L) und einen sinnvollen umask. Und benutzen Sie __nicht__ die Option -w oder -W !
Wenn Sie eine Warez Seite möchten, dann hören Sie nun bitte auf dieses Dokument zu lesen!
</p>

<p>
Mehr dazu gibts auf <uri>http://www.pureftpd.org</uri>
</p>

</body>
</section>

<section>
<title>Proftpd</title>
<body>

<p>
Proftpd has had several security problems, but they seem to have fixed most of them. Still apply some enhancements:</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#Don't show the ident of the server
ServerIdent on "Go away"

#Makes it easier to create virtual users
RequireValidShell off

#Use alternative password and group file (passwd uses crypt format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissions
Umask 077

# Timeouts and limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Chroot everyone
DefaultRoot ~

#don't run as root
User  nobody
Group nogroup

#Log every transfer
TransferLog /var/log/transferlog

#Problems with globbing
DenyFilter \*.*/
</pre>

<p>
The rest is up to you and your reading ability (<uri>http://www.proftpd.org</uri>).
</p>

</body>
</section>

<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (stands for very secure ftp) is a small ftp daemon running a reasonably default configuration. It is simple and does not have as many features (like virtual users) as pureftp and proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#read only
write_enable=NO

#enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
As you see there is no way for this service to have individual permissions and no default chroot action. But when it comes to anonymous settings it quite good. Sometimes it can be nice to have a anonymous ftp server (for sharing open source) and this server really applies for that.
</p>

</body>
</section>

</body>
</section>

<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) comes with a pretty decent configuration file but again. We need to improve some things, like binding to one address and keep it from leaking information. These are the options that you should apply the configuration file:
</p>

<p>
If you have added ssl to your <path>/etc/make.conf</path> before installing apache, you should have access to a ssl enabled server. Just add the following line to enable it.
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Make it listen on your ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#It is not a good idea to use nobody or nogroup - 
#for every service not running as root 
#(just add the user apache with group apache)
User apache
Group apache
#Will keep apache from telling about the version
ServerSignature Off
ServerTokens min
</pre>

<p>
Apache is compiled with --enable-shared=max and --enable-module=all. This will per default enable all modules so you should out comment all modules in the LoadModule section (LoadModule and AddModule) that you do not use. Restart the service by executing <c>/etc/init.d/apache restart</c>.
</p>

<p>
Documentation can be found at <uri>http://www.apache.org</uri>
</p>

</body>
</section>

<section>
<title>Mail</title>
<body>


<section>
<title>Postfix</title>
<body>
TODO!
</body>
</section>

<section>
<title>Qmail</title>
<body>
<p>
Qmail is considered to be the most secure mail server. It is written with security (and paranoia) in mind. It does not allow relaying per default and have not had a security hole since 1996. Simply <c>emerge qmail</c> and go configure!
</p>
</body>
</section>

</body>
</section>

<section>
<title>DNS</title>
<body>
<p>
Gentoo supports two different dns servers, Bind and djbdns.
</p>

<section>
<title>Bind</title>
<body>

<p>
Bind is known for its security history that should not be taken lightly. As with any other service it should __never__ run as root so please don't change the default configuration for this service. Per default Gentoo does not setup any configuration for this services so you have to add your own dns zones to <path>/etc/bind/named.conf</path>. But since the security lies not only within the domain server daemon but also in the protocol it should be properly configured.
</p>

<p>
People often ask, why not use djbdns (very secure dns by D.J. Bernstein) and the answer is: Bind does have features that djbdns does not, like support for IPv6 (not without a patch anyway).
</p>

<pre caption="/etc/bind/named.conf">
#setup access control
acl "mynet" { 10.0.0.0/24; };

options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
#allow "mynet" to make queries
  allow-query { "mynet"; };
#don't allow zone transfers
  allow-transfer { none; };
  forward only;
  forwarders { 10.0.0.2; };
#Only provide recursive service to "mynet"
  recursion no;
  allow-recursion { mynet; };
# Bind to an interface
  listen-on { 10.0.0.1; };
# Don't show the version
  version "Go away";
};

key "rndc-key" {
  algorithm hmac-md5;
  secret "o1BYkYC+bXeZgHDsrVBwRQ==";
};

#allow only control from localhost and with a key
controls {
  inet 127.0.0.1 port 953
  allow { 127.0.0.1; } keys { "rndc-key"; };
};
</pre>

<p>
This is a default good configuration. However, Bind version 9 has a special chroot functionality that you should use. Here is how you create your chrooted bind:
</p>

<pre caption="Prepairing a chroot environment">
# <i>mkdir -p /chroot</i>
# <i>mkdir /chroot/dns</i>
# <i>mkdir /chroot/dns/dev</i>
# <i>mkdir /chroot/dns/etc</i>
# <i>mkdir /chroot/dns/var</i>
# <i>mkdir /chroot/dns/var/run</i>
# <i>mkdir /chroot/dns/var/run/named</i>
# <i>chown -R named:named /chroot/dns/var/run/named</i>
# <i>cp -R /etc/bind /chroot/dns/etc/.</i>
# <i>cp /etc/localtime /chroot/dns/etc/localtime</i>
# <i>cp -R /var/bind /chroot/dns/var/.</i>
# <i>mknod /chroot/dns/dev/zero c 1 5</i>
# <i>chmod 666 /chroot/dns/dev/zero</i>
# <i>mknod /chroot/dns/dev/random c 1 8</i>
# <i>chmod 666 /chroot/dns/dev/random</i>
# <i>cp -a /dev/log /chroot/dns/dev/log</i>
# <i>cd /chroot/dns</i>
# <i>chattr +i etc etc/localtime var</i>
</pre>

<p>
This will create a chrooted environment in <path>/chroot</path>. Now all we have to do is modify the init script for supporting the new environment. Edit <path>/etc/init.d/named</path> and add <c>-t /chroot/dns</c> to the start function. You may also want to change the stop function to point to the correct pid file in <path>/chroot/var/run/named/named.pid</path>. Restart your DNS server.
</p>
<note>
An attacker can escape a chrooted jail, if he is good enough (see how to prevent this in the kernel patch section)
</note>

<p>
Documentation can be found at the <uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software Consortium</uri>
</p>

</body>
</section>

<section>
<title>Djbdns</title>
<body>

<p>
There is really not much to say about djbdns except that the author is willing to bet <uri link="http://cr.yp.to/djbdns/guarantee.html">money</uri> on how secure it is. So go and try it: <uri>http://www.djbdns.org/</uri> it is very different from the way Bind v.9 works but you will get the hang of it.
</p>

</body>
</section>

</body>
</section>

<section>
<title>Samba</title>
<body>

<p>
Samba is a protocol to share files with Microsoft/Novell networks and it should __not__ be used over the Internet. But nevertheless it needs securing.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Bind to an interface
  interfaces = eth0 10.0.0.1/32

  #Make sure to use encrypted password
  encrypt passwords = yes
  directory security mask = 0700

  #allow traffic from 10.0.0.*
  hosts allow = 10.0.0.

  #Enables user authentication 
  #(don't use the share mode)
  security = user
  
  #Disallow privileged accounts
  invalid users = root @wheel

  #Add a max size of usage in kilobytes
  max disk size = 102400

  #Uphold the password policy
  min password length = 8
  null passwords = no

  #Use PAM (if added support)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Make sure that permissions are set correct on every share and remember to read the <uri link="http://www.samba.org">documentation</uri>
</p>

<p>
Now restart the server and add the users who should have access to this service. This is done though the <path>/usr/bin/smbpasswd</path> with the parameter -a
</p>

</body>
</section>

<section>
<title>Chroot or virtual servers.</title>
<body>
<p>
Chrooting a service is a way of limiting a service (or user) environment to only accessing what it should and not gaining access (or information) that could lead to root access. By running the service as another user than root (nobody, apache, named) an attacker can only access files with the permissions of this user. This means that an attacker cannot gain root access even if the services has a security flaw.
</p>

<p>
Some services like pure-ftpd and bind has features for chrooting, and other services has not. If the service supports it, use it, otherwise you have to figure out how to create your own. Lets see how to create a chroot, for a basic understanding of how chroots work, we will test it with bash (easy way of learning).
</p>

<p>
Create a directory in <path>/</path> called chroot (<c>mkdir chroot</c>). And find what dynamic libraries that bash is compiled with (if it is compiled with -static this step is not necessary):
</p>

<p>
The following command will create a list of libraries used by bash. 
</p>

<pre caption="Get listing of used libraries">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Now lets create the environment for bash.
</p>

<pre caption="Create chroot-environment for bash">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Next copy the files used by bash (<path>/lib</path>) to the chrooted lib and copy the bash command to the chrooted bin directory. This will create the excact same environment, just with less functionality. After copying try it out: <c>chroot /chroot/bash</c>. If you get an prompt saying <c>/</c> it works!. Otherwise it will properly tell you what a file is missing. Some shared libraries depend on each other.
</p>

<p>
You will notice that inside the chroot nothing works except echo. This is because we have no other commands in out chroot environment that bash and "echo" is a build-in functionality.
</p>

<p>
This is basically the same way you would create a chrooted service. The only difference is that services sometimes rely on devices and configuration files in <path>/etc</path>. Simply copy them (devices can be copied with cp -a) to the chrooted environment, edit the init script to use chroot before executing. It can be difficult to find what devices and configuration files a services need. This is where the <c>strace</c> command becomes handy. Start the service with <path>/usr/bin/strace</path> bash and look for open, read, stat and maybe connect. This will give you a clue on what files to copy. But in most cases just copy the passwd file (edit the copy and remove users that has nothing to do with the service), <path>/dev/zero</path>, <path>/dev/log</path> and <path>/dev/random</path>.
</p>

<p>
Another way of creating a more secure environment is by using a virtual server environment. This will create a copy of the existing Linux and boots it in a virtual mode. This means that if the server is compromised its only the virtual server that has been compromised and not the real installation.
</p>

<p>
Examples of virtual servers:
</p>

<ul>

<li>
<uri link="http://user-mode-linux.sourceforge.net">Usermode linux</uri> and an howto about <uri link="http://www.gentoo.org/doc/uml.html">user mode linux</uri>.
</li>

<li>
<uri link="http://www.solucorp.qc.ca/miscprj/s_context.hc">Virtual private servers</uri>
</li>

</ul>

</body>
</section>

</chapter>

-- Securing Services end --

-- Firewalls --

<chapter>
<title>Firewalls</title>

<section>
<title>A firewall</title>
<body>

<p>
People often think that a firewall is the ultimate security, but they are wrong. In most cases a mis configured firewall gives worse security that not having one at all. A firewall is also a piece of software and should be treated the same way as any other service, because is just as likely to have bugs (security holes).
</p>

<p>
So think before implementing one! Do you really need one ? If you think you need one write a policy on how it should work, what type of firewall and who should operate it.
</p>

<p>
Firewalls are used for two purposes:
</p>

<ul>
<li>To keep users (worms/attackers) out</li>
<li>To keep users (employees/children) in</li>
</ul>

<p>
Basically there are three types of firewalls:
</p>

<ul>
<li>Packet filtering</li>
<li>Circuit relay</li>
<li>Application gateway</li>
</ul>

<p>
A firewall should be a dedicated machine running no services (or ssh as the only one) and secured the way this guide recommends it to be.
</p>

</body>
</section>

<section>
<title>Packet filtering</title>
<body>

<p>
All network traffic is in the form of packets. Large traffic is also split up into small packets for easy handling and then reassembled when arriving at it's destination. Every packet contains information on how and where is should be delivered. And these information is exactly what a packing filtering firewall uses. Filtering is based on:
</p>

<ul>

<li>Allow or disallow packets based on source/destination IP address.</li>
<li>Allow or disallow packets based on source/destination port.</li>
<li>Allow or disallow packets according to protocol.</li>
<li>Allow or disallow packets according to flags within a specific protocol</li>

</ul>

<p>
Basically filtering on all data within the header of a packet and not it's content.
</p>

<p>
Weaknesses:
</p>

<ul>
<li>Address information in a packet can potentially be a bogus address or as we say <e>spoofed</e> be the sender</li>
<li>Data or requests within the allowed packet may contain unwanted data that the attacker can exploit known bugs in the services on or behind the firewall</li>
<li>Usually single point of failure</li>
</ul>

<p>
Advantages:
</p>

<ul>
<li>Simple and easy to implement</li>
<li>Can give warnings on a possible attack before they happened (by detecting portscans)</li>
<li>Good for stopping SYN attacks</li>
</ul>

<p>
Examples of free packet filters on Linux:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li><uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri></li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

</body>
</section>

<section>
<title>Circuit relay</title>
<body>

<p>
Or circuit level gateways is a firewall that validates connections before allowing data to be exchanged. This means that is simply does not allow or deny packets based based on the header of the packet but determines whether the connection between both ends is valid according to configurable rules before it opens a session and allows data to and from the allowed source address. Filtering is based on:
</p>

<ul>
<li>Destination/source address</li>
<li>Destination/source port</li>
<li>A period of time</li>
<li>Protocol</li>
<li>User</li>
<li>Password</li>
</ul>

<p>
All traffic is validated, monitored and traffic without is disallowed.
</p>

<p>
Weakness:
</p>

<ul>
<li>
Operates at the Transport Layer and may require substantial modification of the programming which normally provides transport functions.
</li>
</ul>

</body>
</section>

<section>
<title>Application gateway</title>
<body>

<p>
The application level gateway is a proxy for application, exchanging data with remote system on behalf of it's clients. It is kept away from the public safely behind a DMZ or firewall with no connection from the outside. Filtering is based on:
</p>

<ul>
<li>Allow or disallow based on source/destination</li>
<li>Based on the packets content</li>
<li>Can even alter the packet content on the fly</li>
<li>Limiting file access based on file type or extension</li>
</ul>

<p>
Advantages:
</p>

<ul>
<li>Can cache files, increasing network performance</li>
<li>Detailed logging of all connections</li>
<li>Scales perfectly (some proxy servers can "share" the cached data)</li>
<li>No direct access from the outside</li>
</ul>

<p>
Weakness:
</p>

<ul>
<li>The setup is complex</li>
</ul>

<p>
Application gateways are considered to be the most secure solution since it does not have to run as root and is not public to the Internet.
</p>

<p>
Example of a free application gateway:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>

<section>
<title>Iptables</title>
<body>

<p>
In order to get iptables working, it has to be enabled in the kernel. I have added them as modules (the iptables command will load them as they are needed) and recompiled my kernel. After you have compiled it (or while compiling the kernel) you have to add the iptables commands. Just <c>emerge iptables</c> and it should work.
</p>

<p>
Now test that it works by running <c>iptables -L</c>. If it fails something is wrong and you have to check you configuration once more.
</p>

<p>
Iptables is a stateful packet filter which means that it provides greater control and greater security than ipchains (Linux version 2.2) which is not stateful. You are properly asking yourself what is the stateful part ? and what is the difference?. 
</p>

<p>
We all know that TCP are made up a series of packets. Each packet containing information about source address, the destination address and a sequence so the packets can be put back together. And we all know that TCP is connection-oriented and UDP is connectionless right? these are the states that it stores .. now you are probably asking yourself and so what ? Well I'm getting to that.
</p>

<p>
Now imagine that you have a stateless firewall (ipchains) and do not want to allow external computers to originate a connection to your internal services but how can the firewall determine whether a packet is part of an ongoing connection or not? A stateless firewall cannot distinguish between an existing connection and one that is part of a new connection by looking at the SYN flag!. 
</p>

<p>
Lets say an attacker is sending hand crafted packets (a packet created by the attacker) where he alters the SYN flags or any other flags. This is quite often that attackers do. Send packets right through the firewall altering routing tables or compromising services running on the firewall but are supposed to be safe behind a filter. A stateful firewall will keep track of all connection and can easily detect if a packet is claiming to part of en existing connect or not. When a connection, claiming to be an existing connection but is found, its marted as invalid and its possible to discard it. This will also stop the possibility of "stealth scans" since the connection was invalid.
</p>

<p>
I could probably find a dozen other reasons but I think you got the picture .. simple rules means a smaller firewall configuration meaning that its easier to maintain.
</p>

<p>
Iptables provides several other features like rate limiting. This features is extremely useful when trying to prevent a certain DoS (Denial of Service) attacks like a SYN attack. Now what is a SYN attack?
</p>

<p>
Again .. when creating a connection with TCP it uses three-way handshake to establish the connection like this:
</p>

<fig link="http://www.ibiblio.org/pub/Linux/distributions/gentoo/images/synack.jpg" short="Three-way handshake"/>

<p>
A SYN attack is when it only sends a SYN packet (header only contains SYN flag) and does not continue sending the last two packets to establish the connection. A SYN packets does not require a valid sender address (IP) because it does not need a reply. So the connection will hang until it times out. Now if the attacker sends a lot of SYN packets with a bogus sender IP, the computer waits for the response, which never comes. Depending on the timeout settings in your system, this connection could stay open for 30-60 seconds (or longer). When the connection limit table is completely occupied and unable to communicate with anyone.
</p>

<p>
This is where the rate limit becomes handy. Its possible to limit the number of SYN packets from a single source but using the <c>-m limit --limit 1/s</c>. This will limit the SYN packets to one per source and therefor restricting the SYN flood on our resources.
</p>

<p>
Now! some practical stuff!
</p>

<p>
When iptables is loaded in the kernel it has 5 hooks where you can place your rules. They are called INPUT, OUTPUT FORWARD, PREROUTING and POSTROUTING. These lists are called chains because they work by added a rules and checks the rules one at the time as they where added. If one rule deny a packet it will be dropped and does not continue down the chain.
</p>

<p>
You can place rules directly to the 5 main chains or create chains and add them to as a rule to an existing chain. Lets see how this is done
</p>

<table border="0">
  <tr>
    <th>Option:</th><th>Description:</th>
  </tr>
  <tr>
    <ti>-A</ti><ti>Append</ti>
  </tr>
  <tr>
    <ti>-D</ti><ti>Delete</ti>
  </tr>
  <tr>
    <ti>-I</ti><ti>Insert</ti>
  </tr>
  <tr>
    <ti>-R</ti><ti>Replace</ti>
  </tr>
  <tr>
    <ti>-L</ti><ti>List</ti>
  </tr>
  <tr>
    <ti>-F</ti><ti>Delete all rules in  chain or all chains</ti>
  </tr>
  <tr>
    <ti>-Z</ti><ti>Zero counters in chain or all chains</ti>
  </tr>
  <tr>
    <ti>-C</ti><ti>Test this packet on chain</ti>
  </tr>
  <tr>
    <ti>-N</ti><ti>Create a new user-defined chain</ti>
  </tr>
  <tr>
    <ti>-X</ti><ti>Delete a user-defined chain</ti>
  </tr>
  <tr>
    <ti>-P</ti><ti>Change policy on chain to target</ti>
  </tr>
  <tr>
    <ti>-E</ti><ti>Change chain name</ti>
  </tr>
  <tr>
    <ti>-p</ti><ti>Protocol</ti>
  </tr>
  <tr>
    <ti>-s</ti><ti>Source address/mask</ti>
  </tr>
  <tr>
    <ti>-d</ti><ti>Destination address/mask</ti>
  </tr>
  <tr>
    <ti>-i</ti><ti>Input name (ethernet name)</ti>
  <tr>
  </tr>
    <ti>-o</ti><ti>Output name (ethernet name)</ti>
  </tr>
  <tr>
    <ti>-j</ti><ti>Jump (target for rule)</ti>
  </tr>
  <tr>
    <ti>-m</ti><ti>Extended match (might use extension)</ti>
  </tr>
  <tr>
    <ti>-n</ti><ti>Numeric output of addresses and ports</ti>
  </tr>
  <tr>
    <ti>-t</ti><ti>Table to manipulate</ti>
  </tr>
  <tr>
    <ti>-v</ti><ti>Verbose mode</ti>
  </tr>
  <tr>
    <ti>-x</ti><ti>Expand numbers (display exact values)</ti>
  </tr>
  <tr>
    <ti>-f</ti><ti>Match second or further fragments only</ti>
  </tr>
  <tr>
    <ti>-V</ti><ti>Packet version</ti>
  </tr>
  <tr>
    <ti>--line-numbers</ti><ti>Print line numbers when listing</ti>
  </tr>
</table>

<p>
First we will try to block all ICMP packages to our machine, just to get familiar with iptables.
</p>

<pre caption="Block all ICMP packages">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
First we specify the chain it should be appended to. Next to specify the protocol and then the rule. The rule can be a ACCEPT, DROP, REJECT, LOG, QUEUE, MASQUERADE, a loaded module or a user defined chain. In this case we use DROP which will drop the packet without responding to the client.
</p>

<p>
Now try <c>ping localhost</c>. It will not be able to get any response since its blocking the entire ICMP protocol incoming to our machine. It will not be able to ping other machines either since its not allowed to get the ICMP packets returning from the host. Now flush the chain to get ICMP flowing again.
</p>

<pre caption="Flush all rules">
# <i>iptables -F</i>
</pre>

<p>
Now lets look at the stateful part in iptables. If we wanted to have a stateful inspection of packets incoming on eth0 we could enable it by issuing:
</p>

<pre caption="Accept packets that originate from an already established connection">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
This will accept any packet already established or related in the INPUT chain. And you could drop any packet that is not in the state table by issuing <c>iptables -A INPUT -i eth0 -m state --state INVALID -j DROP</c> just before. This enables the stateful part in iptables by loading the extension state. If you wanted connection from the outside to connect to you machine you could use the <c>--state NEW</c>. Iptables contain some modules for different purposes. Some of them are: 
</p>

<table border="0">
  <tr>
    <th>Module/Match</th><th>Description</th><th>Extended options</th>
  </tr>
  <tr>
    <ti>mac</ti><ti>Matching extension for incoming packets mac address.</ti><ti>--mac-source</ti>
  </tr>
  <tr>
    <ti>state</ti><ti>Enables stateful inspection</ti><ti>--state (states are ESTABLISHED,RELATED, INVALID, NEW)</ti>
  </tr>
  <tr>
    <ti>limit</ti><ti>Rate matching limiting</ti><ti>--limit, --limit-burst</ti>
  </tr>
  <tr>
    <ti>owner</ti><ti>Attempt to match various characteristics of the packet creator</ti><ti>--uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner sessionid</ti>
  </tr>
  <tr>
    <ti>unclean</ti><ti>Various random sanity checks on packets</ti><ti/>
  </tr>
</table>

<p>
Lets try to create a user defined chain and apply it to one of the existing chains:
</p>

<pre caption="Creating a userdefined chain">
<codenote>Create a new chain with one rule</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>The default policy is all outgoing traffic is allowed. Incoming is dropped.</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>And add it to the INPUT chain</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
By applying the rule to the input chain we get the policy: All is allowed out and only incoming is allowed, if its already established. This is general a bad idea. Default policies should be drop but this is just an example.
</p>

<p>
Now if you want more documentation have a look at the <uri link="http://www.iptables.org/documentation/index.html#HOWTO">iptables documentation</uri>
</p>

<p>
Lets see a full blown example. In this case my firewall/gateway policy states:
</p>

<ul>
  <li>Connections to the firewall is only allowed through SSH (port 22)</li>
  <li>The local network should have access to HTTP, HTTPS and SSH (DNS should also be allowed)</li>
  <li>ICMP traffic can contain payload as should not be allowed. Of course we have to allow some ICMP traffic.</li>
  <li>Port scan should be detected and logged</li>
  <li>SYN attack should avoided</li>
  <li>All other traffic should be dropped and logged</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net procparam
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default rule
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffic
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Incoming traffic
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -p tcp --dport ssh -j ACCEPT

  #outgoing traffic
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Catch portscanners
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Apply and add invalid states to the chains
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Allow client to route through via NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>
<note>I backslashed some lines for readability issues. It might be a good idea to join this lines in an actual configuration. Get it <uri link="firewall.gz">here</uri>.</note>

<p>
Free advice when creating a firewall:
</p>

<ol>
  <li>Create your firewall policy before implementing it</li>
  <li>Keep it simple</li>
  <li>Know how the protocol works (read the <uri link="http://www.ietf.org/">RFC (Request For Comments)</uri>)</li>
  <li>Keep in mind that a firewall it just another piece of software running as root</li>
  <li>Test your firewall</li>
</ol>

<p>
If you think that iptables is hard to understand or takes to long to setup a decent firewall you could use <uri link="http://www.shorewall.net">Shorewall</uri>. It basically uses iptables to generate firewall rules, but concentrates on rules and not specific protocols.
</p>

</body>
</section>

<section>
<title>Squid</title>
<body>

<p>
Squid is a very powerful proxy server and it can do filters, rejects allowed traffic based on: time, regular expression path/uri, source and destination address (IP), domain, browser, the authenticated username, mime-type and port (protocol). I probably forgot some features, but it can be hard to cover the entire feature list.
</p> 

<p>
In the following example I have added a banner filter instead of a filter based on porn sites. The reason for this is that Gentoo.org should <c>not</c> be listed as some porn site. And I do not want to waste my time trying to find some good sites for you.
</p>

<p>
In this case, my policy states:
</p>

<ul>
  <li>Surfing (HTTP/HTTPS) is allowed during work hours (mon-fri 8-17 and sat 8-13) if they are here late they should work, not surf</li>
  <li>Download is not allowed (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg etc.)</li>
  <li>We don't like banners so they are filtered and replaced with a transparent gif (this is where you get creative!)</li>
  <li>Every other connection to and from the Internet is not allowed</li>
</ul>

<p>
This is implemented in 4 "easy" steps
</p>

<pre caption="/etc/squid/squid.conf">
# Bind to a ip and port
http_port 10.0.2.1:3128

# Standard configuration
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Add basic access control lists
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Add who can access this proxy server
acl localnet src 10.0.0.0/255.255.0.0

# And ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Add access control list based on regular
# expressions within urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Add access control list based on time and day
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#allow manager access from localhost
http_access allow manager localhost
http_access deny manager

# Only allow purge requests from localhost
http_access allow purge localhost
http_access deny purge

# Deny requests to unknown ports
http_access deny !Safe_ports

# Deny CONNECT to other than SSL ports
http_access deny CONNECT !SSL_ports

# My own rules

# Add a page do be displayed when
# a banner is removed
deny_info NOTE_ADS_FILTERED url_ads

# Then deny them
http_access deny url_ads

# Deny all archives
http_access deny archives

# Restrict access to work hours
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Deny the rest
http_access deny all
</pre>

<p>
Next fill in the files you do not want your uses to download. I have added zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz and z files.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
Please note the [] with upper and lowercase of every character. This is done so no one can fool it by accessing a file called AvI instead of avi
</note>

<p>
Next we add the regular expressions for identifying banners. You will probably be a lot more creative than me:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
And the last part. We want this file to be displayed when it removes a banner. It's basically a half html file with a 4x4 transparent gif image.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://www.insecurity.dk/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
Don't close the &lt;HTML&gt; &lt;BODY&gt; tags. This will be done by squid.
</note>

<p>
As you can see squid has a lot of possibilities and it is very effective in both filtering and proxying. It can even use alternative squid proxies to scale on very large networks. The config I have listed here is mostly suited for a small network with 1-20 users.
</p>

<p>
But combining the packet filter (iptables) and the application gateway (squid) is probably the best solution, even if squid is located somewhere safe and nobody could access it from the outside. We still need to be concerned on attack from the inside.
</p>

<p>
Now you have to add the proxy server into the settings of your clients browsers. The gateway will prevent the users from having any contact with the outside unless they use the proxy.
</p>
<note>
In Mozilla this is done in Edit->Preferences->Advanced->Proxies.
</note>

<p>
It can also be done transparently by using iptables to forward all traffic out to a squid proxy. This can be done by adding a forwarding/prerouting rule on the gateway:
</p>

<pre caption="Enable portforwarding to our proxyserver">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>

<section>
<title>Now what have we learned?</title>

<body>

<p>
We have learned that:
</p>

<ol>
  <li>A firewall can be a risk itself. A badly configured firewall is worse then not having one at all.</li>
  <li>How to setup a basic gateway and a transparent proxy</li>
  <li>The key to a good firewall is to know the protocol you want do allow</li>
  <li>That IP traffic does not always contain legitimate data. For an example ICMP packets with payload</li>
  <li>How to be prevent SYN attack</li>
  <li>Filtering HTTP traffic by removing offensive pictures and downloads of viruses.</li>
  <li>Combining packet filters and application gateways gives a better control</li>
</ol>

<p>
Now, if you <b>really</b> need to, go create a firewall that matches your needs.
</p>

</body>
</section>

</chapter>

-- Intrusion detection start --

<chapter>
<title>Intrusion detection</title>

<section>
<title>Aide (Advanced Intrusion Detection Environment)</title>
<body>

<p>
Aide is a host based intrusion detection detection system (free alternative to Tripwire). And if you already know Tripwire you should have no difficulties learning the configuration file for Aide.
</p>

<p>
The configuration file is based on regular expressions, macros and rules for files and directories. We have the following macros: 
</p>

<table borlder="0">
  <tr>
    <th>Macro</th><th>Description</th><th>Syntax</th>
  </tr>
  <tr>
    <ti>ifdef</ti><ti>If definded</ti><ti>@@ifdef "name"</ti>
  </tr>
  <tr>
    <ti>ifndef</ti><ti>If not defined</ti><ti>@@ifndef "name"</ti>
  </tr>
  <tr>
    <ti>define</ti><ti>Define a variable </ti><ti>@@define "name" "value"</ti>
  </tr>
  <tr>
    <ti>undef</ti><ti>Undefine a variable</ti><ti>@@undef "name"</ti>
  </tr>
  <tr>
    <ti>ifhost</ti><ti>if "hostname"</ti><ti>@@ifhost "hostname"</ti>
  </tr>
  <tr>
    <ti>ifnhost</ti><ti>if not "hostname"</ti><ti>@@ifnhost "hostname"</ti>
  </tr>
  <tr>
    <ti>endif</ti><ti>Endif must be used after any of the above macros except define and undef</ti><ti>@@endif</ti>
  </tr>
</table>

<p>
These macros become very handy if you have more than one Gentoo box and want to use Aide on all of them. But not all machines run the same services or maybe even users.
</p>

<p>
Next we have sets of flags to check for on files and directories. These are a combination  of permissions, file
properties and cryptographic hashes/checksums.
</p>

<table border="0">
  <tr>
    <th>Flag</th><th>Description</th>
  </tr>
  <tr>
    <ti>p</ti><ti>permissions</ti>
  </tr>
  <tr>
    <ti>i</ti><ti>inode</ti>
  </tr>
  <tr>
    <ti>n</ti><ti>number of links</ti>
  </tr>
  <tr>
    <ti>u</ti><ti>user</ti>
  </tr>
  <tr>
    <ti>g</ti><ti>group</ti>
  </tr>
  <tr>
    <ti>s</ti><ti>size</ti>
  </tr>
  <tr>
    <ti>b</ti><ti>block count</ti>
  </tr>
  <tr>
    <ti>m</ti><ti>mtime</ti>
  </tr>
  <tr>
    <ti>a</ti><ti>atime</ti>
  </tr>
  <tr>
    <ti>c</ti><ti>ctime</ti>
  </tr>
  <tr>
    <ti>S</ti><ti>check for growing size</ti>
  </tr>
  <tr>
    <ti>md5</ti><ti>md5 checksum</ti>
  </tr>
  <tr>
    <ti>sha1</ti><ti>sha1 checksum</ti>
  </tr>
  <tr>
    <ti>rmd160</ti><ti>rmd160 checksum</ti>
  </tr>
  <tr>
    <ti>tiger</ti><ti>tiger checksum</ti>
  </tr>
  <tr>
    <ti>R</ti><ti>p+i+n+u+g+s+m+c+md5</ti>
  </tr>
  <tr>
    <ti>L</ti><ti>p+i+n+u+g</ti>
  </tr>
  <tr>
    <ti>E</ti><ti>Empty group</ti>
  </tr>
  <tr>
    <ti>&gt;</ti><ti>Growing logfile p+u+g+i+n+S</ti>
  </tr>
</table>

<p>
And if Aide is compiled with mhash support it does have a few other features:
</p>

<table border="0">
  <tr>
    <th>Flag</th><th>Description</th>
  </tr>
  <tr>
    <ti>haval</ti><ti>haval checksum</ti>
  </tr>
  <tr>
    <ti>gost</ti><ti>gost checksum</ti>
  </tr>
  <tr>
    <ti>crc32</ti><ti>crc32 checksum</ti>
  </tr>
</table>

<p>
Now you can create you own rules based on the above flags by combining them like:
</p>

<pre caption="Create a ruleset for AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
The last thing we need to create our own configuration file is to see how to add a rule to a file or directory. Basically you just type the file or dir name and the rule. Aide will add all files recursively unless you specify something else.
</p>

<table border="0">
  <tr>
    <th>Flag</th><th>Description</th>
  </tr>
  <tr>
    <ti>!</ti><ti>Don't add this file or directory.</ti>
  </tr>
  <tr>
    <ti>=</ti><ti>Add this directory, but not recursive.</ti>
  </tr>
</table>

<p>
So lets watch a full blown example
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOP DIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# The location of the database to be read.
database=file:@@{AIDEDIR}/aide.db

# The location of the database to be written.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Rule definition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
In the above example we specify some macros with where the topdir starts and where the aide directory is. Aide checks the <path>/etc/aide/aide.db</path> file when checking for file integrity. But when updating or creating a new file it stores the information in <path>/etc/aide/aide.db.new</path>. This is done so it won't automatic overwrite the old db file. The option report_URL is a "to come" feature that really has no meaning yet. But the authors intention was that it should be able to email or maybe even execute script.
</p>

<p>
After the configuration you should create your db file by executing aide -i and then copy the file <path>/etc/aide/aide.db.new</path> to <path>/etc/aide/aide.db</path> and add the check to cron by executing crontab -e as root.
</p>
<note>Depending on you cpu, disk access and the flags you have set on files, it can take some time</note>

<pre caption="Shedule aide as a cronjob">
0 3   * * * /usr/bin/aide -u
</pre>
<note>Remember to setup so you get roots mail. Otherwise you will never know what aide reports</note>

<p>
In this case it runs once at 3pm. This is done since I do not want to disturb the users when working. Note I'm using the -u (Update) option instead of the -C (Check). Since -u also checks the files and does not overwrite the original db file it saves some time since all you need to do is to copy a file when it detects some changes. Just check the changes to see if it was yourself that made the changes or some attacker before you copy it!
</p>

<p>
Now there is some problems with storing the db files locally since the attacker will (If he knows that aide is installed) most certainly try to alter the db file, update the db file or modify <path>/usr/bin/aide</path>. So you should create a CD or other media and put a copy of the .db file and the aide binaries.
</p>

<p>
More information can be found at <uri link="http://www.cs.tut.fi/~rammer/aide.html">aide's</uri> projectpage.
</p>

</body>
</section>

<section>
<title>Snort</title>
<body>

<pre caption="Add a user snort to the system">
# user add snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PID FILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOG DIR="/var/log/snort"
CO NF=/etc/snort/snort.Cong
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>Step 1</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>Step 2</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>Step 3</codenote>
include classification.config

<codenote>Step 4</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
More information can be found at <uri link="http://www.snort.org">Snorts</uri> website.
</p>

</body>
</section>

</chapter>

-- Intrusion detection end --

<chapter>
<title>Changes since last version</title>
<section>
<title>Changes</title>
<body>

<p>
Version 0.1 -> 0.2
</p>
<ul>
  <li>Fixed a lot of typos found by various people (Mostly by Bjarke Sørensen)</li>
  <li>Changes to tie apache.conf (ServerTokens min)</li>
  <li>Fixed problem with pre-tags more than 80 chars wide</li>
  <li>Added a firewall chapter</li>
</ul>

<p>
Version 0.2 -> 0.4
</p>
<ul>
  <li>Added a chapter on intrusion detection.</li>
  <li>Fixed a bug in the firewall script.</li>
</ul>

</body>
</section>
</chapter>



<chapter>
<title>FAQ</title>

<section>
<title>Answars and questions</title>
<body>

<table border="0">
  <tr>
    <th>Question</th><th>Answar</th>
  </tr>
  <tr>
    <ti>Where can I find the latest version of this guide?</ti><ti>The lastest version should be available on <uri>http://gentoo.org</uri> and the development version at <uri>http://gentoo.insecurity.dk</uri></ti>
  </tr>
</table>

</body>
</section>
</chapter>


</guide>
