<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- English CVS Version: 1.21 -->

<!-- $Header: /home/xubuntu/berlios_backup/github/tmp-cvs/gentoo-deutsch/Repository/www-source/daten/doku/handbook/hb-install-disk.xml,v 1.4 2003/12/05 13:41:29 pyrania Exp $ -->

<sections>
<section>
<title>Einführung in Block Devices</title>
<subsection>
<title>Block Devices</title>
<body>

<p>
Wir werden einen guten Einblick in die Festplatten bezogenen Aspekte von Gentoo
Linux und Linux im allgemeinen, inklusive Linux Dateisystemen, Partitionen und
Block Devices erhalten.
Dann, sobald Sie mit den Vor- und Nachteilen von Festplatten und Dateisystemen
vertrut sind, werden Sie durch den Prozess des Partitionierens und der
Dateisystem Erstellung für Ihre Gentoo Linux Installation geführt.
</p>

<p>
Zu Beginn werden wir Ihnen <e>Block Devices</e> vorstellen. Das berühmteste
Block Device is warscheinlich das, welches das erste IDE Laufwerk in einem Linux
System repräsentiert, namentlich <path>/dev/hda</path>. Wenn Ihr System SCSI
Laufwerke verwendet, dann wäre Ihre Erste Festplatte <path>/dev/sda</path>.
</p>

<p>
Das obige Block Device repräsentiert ein abstractes Interface zur Festplatte.
Benutzerprogramme können diese Block Deviced benutzen, um Ihrer Festplatte
anzusprechen, ohne sich darum zu kümmern, ob Ihre Festplatten IDE, SCSI oder
irgendwas anderes sind. Das Programm kann den Speicherplatz auf der Festplatte
*einfach als eine anhäufung von zusammenhängenden, zufällig zugreifbaren
512-Byte Blöcken ansprechen.
</p>

</body>
</subsection>
<subsection>
*<title>Partitionen und Slices</title>
<body>

<p>
Obwohl es theoretisch möglich ist eine ganze Festplatte zu nutzen, um Ihr Linux
System zu beherbergen, wird dies in der Praxis so gut wie nie gemacht.
Stattdessen werden komplette Festplatten Block Devices in kleinere, besser
verwaltbare Block Devices unterteilt. Auf den meisten Systemen werden sie
<e>Partitionen</e> gennant. Andere Architekturen benutzen ähnliche Techniken,
welche <e>Slices</e> genannt werden.
</p>

</body>
</subsection>
<subsection>
<title>Partitionen</title>
<body>

<p>
Es wird unter drei Partitionstypen unterschieden:
<e>primar</e>, <e>erweitert</e> und <e>logisch</e>.
</p>

<p>
Eine <e>primäre</e> Partition ist eine Partition, deren Informationen im MBR
(Master Boot Record) gespeichert sind. Da ein MBR sehr klein ist (512 Bytes),
können nur vier primäre Partitionen definiert werden (zum Beispiel
<path>/dev/hda1</path> bis <path>/dev/hda4</path>).
</p>

<p>
Eine <e>erweiterte</e> Partition ist eine spezielle primäre Partition (was
bedeutet, dass eine erweiterte Partition eine der vier möglichen promären
Partitionen sein muss), welche mehrere Partiotionen beinhaltet. Eine solche
Partition existierte ursprünglich nicht, aber da vier Partitionen zu wenig sind,
wurden sie erfunden, um das Format zu erweitern ohne die rückwärts Kompabilität
zu verlieren.
</p>

<p>
Eine <e>logische</e> Partition ist eine Partition innerhalb einer erweiterten
Partition. Ihre Definitionen sind nicht im MBR gespeichert, sondern in der
erweiterten Partition.
</p>

</body>
</subsection>
<subsection>
*<title>Logische Volumes</title>
<body>

<p>
Einige Leute könnten Partitionen und Slices als zu beschränkt empfinden. Wenn
Sie genauso denken, sollten Sie einen blick auf LVM werfen -- den <e> Logischen
Volume Manager</e>
</p>

<p>
Bei LVM erstellen Sie Partitionen (oder Slices) wie gewohnt, aber Sie werden sie
nicht nutzen um ihr Linux System zu beherbergen. Stattdessen fügen Sie eine
weitere Ebene des Speichers (die LVM Ebene) hinzu, auf welcher Sie Gentoo Linux
installieren. Aber was sind die Vorteile von LVM?
</p>

<p>
Mit LVM können Sie ganz einfach die Größe des Volumes ändern, auf dem Sie Gentoo
installiert haben.
Zudem können Sie Backups eines Volumes machen, ohne das System einzufrieren,
wodurch Sie Ihre Backup Strategie für Ihre User transparenter (und weniger
Problemreich) machen können.
Ein weiterer Vorteil ist, dass Sie mehrere Festplatten zu einem einzelnen
Volume hinzufügen können (was bedeutet, wenn eines Ihrer Volumes wenig freien
Speicherplatz zur verfügung hat, können Sie es erweitern ohne Dateien
rumkopieren zu müssen).
</p>

<p>
Ein LVM ist in drei abstrakte Teile unterteilt. Sie haben ein <e>physichses
Volume</e>, welches eine Partition, Slice oder Festplatte ist, welche Sie
benutzen wollen, um den LVM Layer darauf zu speichern.
Dann gibt es noch eine <e>Volume Gruppe</e> der Sie bestimmte physische
Volumes zuweisen können. Diese Volume Gruppe beinhaltet verschiedene <e>logische
Volumes</e> welche eine Art von Virtuellen Partitionen sind.
</p>

<p>
Diese logischen Volumes werden als normale Partitionen benutzt; wenn ein
logisches Volume nun mehr Speicherplatz benötigt, kann es den verfügbaren
Speicher in seiner Volume Gruppe nutzen um sich selbst zu erweitern. Wenn die
Volume Gruppe nicht genügend Speicherplatz hat, können Sie weitere physische
Volumes hinzufügen - vollkommen transparent zum User (z.B. müssen Sie keine
Daten verschieben, das System einfrieren etc.). Dadurch ist ein LVM sehr
flexibel.
</p>

<p>
Wenn Sie LVM benutzen wollen, weisen wir Sie darauf hin, dass ihr root
Dateisystem (<path>/</path>) und Ihr boot Dateisystem (<path>/boot</path>)
außerhalb des LVM liegen müssen. Wenn Sie die meisten Dateien in ein logisches
Volume speichern wollen (<path>/home</path>, <path>/usr</path>,
<path>/tmp</path>, <path>/opt</path> und <path>/var</path>
werden in diesem Handbuch benutzt), muss Ihr root Dateisystem nicht sehr groß
sein (ca. 140 MB sollten genug sein).
</p>

</body>
</subsection>
</section>
<section>
<title>Erstellung eines Partitions Schemas</title>
<subsection>
<title>Standart Partitions Schema</title>
<body>

<p>
Wenn Sie nicht daran interessiert sind ein Partitions Schema für Ihr System zu
erstellen, können Sie das (nicht LVM) Partitions Schema verwenden, welches wir
in diesem Handbuch benutzen:
</p>

<p>
Für x86:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Für ppc:
</p>

<table>
<tr>
  <th>Partition NewWorld</th>
  <th>Partition OldWorld</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(nicht benötigt)</ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Bootstrap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Für Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>Dateisystem</th>
  <th>Größe</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Full disk</ti>
  <ti>Sun Disk Label (benötigt)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Rest der Festplatte</ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Wenn Sie LVM benutzen wollen, sollten Sie eine kleine root Partition anstelle
einer großen erstellen, ignorieren Sie die swap Partition und erstellen Sie eine
große Partition, da Sie die individuelle aufteilung später machen, wenn Sie die
logischen Volumes festlegen. Markieren Sie anschließend diese große Partition
als Typ "Linux LVM" oder "LVM" (8e).
</p>

<p>
Um Gentoo von einer existierenden Distribution aus zu installieren, sollten
Sie, zuerst Ihre bestehenden Partitionen verkleinern (wenn Sie keinen freien
Speicherplatz verfügbar haben). Sie können <uri
link="http://www.gnu.org/software/parted">GNU/Parted</uri> benutzen, um Ihre
Partitionen zu verkleinern.
</p>

<p>
Wenn Sie daran interessiert sind zu erfahren wie groß eine Partition (oder
logisches Volume) sein sollte, oder auch wieviele Partitionen (oder Volumes) Sie
benötigen, lesen Sie weiter. Anderenfalls fahren Sie nun mit dem Partitionieren
Ihrer Festplatte fort:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Benutzung von fdisk auf x86 zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap4">Benutzung von fdisk auf Alpha zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap5">Benutzung von fdisk auf SPARC zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap6">Benutzung von mac-fdisk auf PPC zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap7">Benutzung von fdisk auf HPPA zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Wie viele und wie groß?</title>
<body>

<p>
Die Anzahl an Partitionen (oder logischen Volumes, wenn sie LVM nutzen wollen)
hängt von Ihrer Umgebung ab. Wenn Sie z.B. eine Menge User haben, wollen Sie
höchst wahrscheinlich Ihr <path>/home</path> separat halten, da es die
Sicherheit erhöht und Backups einfacher macht. Wenn Sie Gentoo installieren um
als Mailserver zu fungieren, sollten Sie <path>/var</path> separat halten, da
alle Mails in <path>/var</path> gespeichert werden. Eine gute Wahl des
Dateisystems maximiert dann zusätzlich die Performance. Gameserver sollten ein
separates <path>/opt</path> haben, da die meisten Game Server dort installiert
werden. Der Grund ist ähnlich wie bei <path>/home</path>: 
Sicherheit und Backups.
</p>

<p>
Wie Sie sehen können hängt es sehr stark davon ab, was Sie erreichen wollen.
Separate Partitionen oder Volumes haven folgende Vorteile:
</p>

<ul>
<li>
  Sie können das Filesystem mit der höchsten Performance für jede Partition oder
  jedes Volume auswählen
</li>
<li>
  Ihr komplettes System kka nicht ohne freien Speicherplatz laufen, wenn ein
  defektes Tool ununterbrochen Dateien auf eine Partition oder ein Volume
  schreibt
</li>
<li>
  Falls nötig können Dateisystem Checks Zeitlich verkürzt werden, in dem
  mehrere Checks parallel durchgeführt werden können (obwohl dieser Vorteil eher
  mit mehreren Festplatten als mit mehreren Partitionen zum tragen kommt)
</li>
<li>
  Die Sicherheit kann erhöht werden, indem Sie einige Partitionen oder Volumes
  read-only, nosuid (setuid bits werden ignoriert), noexec (executable bits
  werden ignoriert) etc.
</li>
</ul>

<p>
Wie dem auch sie, mehrere Partitionen haben einen großen Nachteil (wenn Sie kein
LVM benutzen): wenn sie nicht ordentlich konfiguriert werden, könnte das
Tesultat ein System sein welches viel Speicherplatz auf der einen Partition und
keinen auf einder anderen frei hat.
</p>

<p>
Als Beispiel zeigen wir Ihnen die Partitionierung einer 20GB Festplatte, welche
in einem Notebook zu Demonstrationszwecken genutzt wird (inklusive webserver,
mailserver, gnome, ...):
</p>

*<pre caption="Filesystem usage example">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Unpartitionierter Speicherplatz für zukünftige Benutzung: 2 GB)</comment>
</pre>

<p>
<path>/usr</path> ist ziemlich voll (83% used), aber sobald die ganze Software
installiert ist, tendiert <path>/usr</path> nicht mehr dazu allzuviel zu
wachsen.
Man könnte denken der zugewiesene Speicherplatz für <path>/var</path>, sei
zuviel, aber Gentoo kompiliert alle Programme in <path>/var/tmp/portage</path>,
daher sollten Sie für <path>/var</path> mindestens 1GB frei haben, wenn Sie
keine großen Programme installieren wollen; mit einer Größe von bis zu 3GB
sollten auch KDE und OpenOffice.org kein Problem mehr sein.
</p>

<p>
Jetzt partitionieren Sie Ihre Festplatte(n) mit Hilfe der Anleitungen die für
Ihre Architektur als Beispiel zur Verfügung stehen:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Benutzung von fdisk auf x86 zur Partitionierung Ihrer
  	Festplatte
  </uri>
</li>
<li>
  <uri link="#doc_chap4">Benutzung von fdisk auf Alpha zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap5">Benutzung von fdisk auf SPARC zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap6">Benutzung von mac-fdisk auf PPC zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
<li>
  <uri link="#doc_chap7">Benutzung von fdisk auf HPPA zur Partitionierung Ihrer
  	Festplatte</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Benutzung von fdisk auf x86 zur Partitionierung Ihrer Festplatte</title>
<subsection>
<body>

<impo>
Nur Benutzer mit <e>x86</e> basierten System sollten diese Sektion lesen.
</impo>

<p>
Die folgenden Teile erklären, wie das bereits beschriebene Beispiel Partitions
Layout (ohne LVM) erstellt wird:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Beschreibung</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap Partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Root Partition</ti>
</tr>
</table>

<p>
Ändern Sie Ihr Partitionslayout nach Ihrem eigenen willen.
</p>

</body>
</subsection>
<subsection>
<title>Das derzeitge Partitionslayout ansehen</title>
<body>

<p>
<c>fdisk</c> ist ein verbreitetes und mächtiges Tool um Ihre Festplatte in
Partitionen zu teilen. Starten Sie <c>fdisk</c> für Ihre Festplatte (in unserem
Beispiel benutzen wir <path>/dev/hda</path>):
</p>

<pre caption="Starten von fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Sobald Sie in <c>fdisk</c> sind, werden Sie mit folgendem Prompt begrüßt:
</p>

<pre caption="fdisk Prompt">
Command (m for help): 
</pre>

<p>
Drücken Sie <c>p</c> um Ihr derzeitiges Partitionslayout anzeigen zu lassen:
</p>

<pre caption="Ein Beispiel Partitionslayout">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Diese Festplatte beherbergt sieben Linux Dateisysteme (jedes mit einer
dazugehörigen Partition, gelistet als "Linux") und auch eine Swap Partition
(gelistet als "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Löschen aller Partitionen</title>
<body>

<p>
Zuerst entfernen wir alle existierenden Partitionen von der Festplatte. Drücken
Sie <c>d</c> um eine Partition zu löschen. Zum Beispiel um ein bestehendes
<path>/dev/hda1</path> zu löschen:
</p>

<pre caption="Löschen einer Partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Die Partition wurde zur Löschung markiert und wird nicht mehr angezeigt, wenn
Sie <c>p</c> drücken, aber wird nicht gelöscht, bis Sie Ihre Änderungen
gespeichert sind. Wenn Sie einen Fehler gemacht haben und ohne zu speichern
abbrechen wollen, drücken Sie umgehend <c>q</c> und enter; Ihre Partition wird
dann nicht gelöscht.
</p>

<p>
Angenommen, dass Sie wirklich all Ihre Partitionen auf Ihrer Festplatte löschen
wollen, drücken Sie noch einmal <c>p</c> um die Partitionstabelle anzuzeigen und
dann <c>d</c> und die Nummer der Partition die Sie löschen wollen. Irgendwann
werden Sie eine leere Partitionstabelle haben:
</p>

<pre caption="Eine leere Partition Tabelle">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Jetzt, da die Partitions Tabelle im Speicher leer ist, sind wir vorbereitet, um
die Partitionen zu erstellen. Wir werden ein Default Partitions Schema benutzen,
wie wir es zuvor angesprochen haben.
Natuürlich sollten Sie den Instruktionen nicht buchstäblich ausführen, wenn Sie
ein anderes Partitions Schema verwenden wollen!
</p>

</body>
</subsection>
<subsection>
<title>Erstellung der Boot Partition</title>
<body>

<p>
Zuerst erstellen wir eine kleine Boot Partition. Drücken Sie <c>n</c> um eine
neue Partition zu erstellen, dann <c>p</c> um eine primäre Partition zu wählen,
gefolgt von <c>1</c> für die erste primäre Partition. Wenn Sie nach dem ersten
Zylinder gefragt werden, drücken Sie enter. Für den letzten Zylinder geben Sie
<c>+32M</c> ein, um eine 32 MB Partition zu erzeugen.
</p>

<pre caption="Erstellen der Boot Partition">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Wenn Sie jetzt <c>p</c> drücken, solltgen Sie die folgende Partitionstabelle
sehen:
</p>

<pre caption="Erstellte Boot Partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Erstellen der Swap Partition</title>
<body>

<p>
Let's now create the swap partition. To do this, type <c>n</c> to create a new 
partition, then <c>p</c> to tell fdisk that you want a primary partition. Then 
type <c>2</c> to create the second primary partition, <path>/dev/hda2</path> in
our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After
you've done this, type <c>t</c> to set the partition type, <c>2</c> to select 
the partition you just created and then type in <c>82</c> to set the partition 
type to "Linux Swap". After completing these steps, typing <c>p</c> should
display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating a swap partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Root Partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then <c>p</c> to tell fdisk that you want a primary partition. 
Then type <c>3</c> to create the third primary partition, <path>/dev/hda3</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for
the last cylinder, hit enter to create a partition that takes up the rest of the
remaining space on your disk. After completing these steps, typing <c>p</c> 
should display a partition table that looks similar to this:
</p>

<pre caption="Partition listing after creating the root partition">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Saving the Partition Layout</title>
<body>

<p>
To save the partition layout and exit <c>fdisk</c>, type <c>w</c>.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your partitions are created, you can now continue with <uri
link="#doc_chap9">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#doc_chap8">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on Alpha to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>Alpha</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example slice layout described
previously, namely:
</p>

<table>
<tr>
  <th>Slice</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Swap slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Root slice</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Full disk (required)</ti>
</tr>
</table>

<p>
Change your slice layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Identifying Available Disks</title>
<body>

<p>
To figure out what disks you have running, use the following commands:
</p>

<pre caption="Identifying available disks">
<comment>(For IDE disks)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(For SCSI disks)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
From this output you should be able to see what disks were detected and their
respective <path>/dev</path> entry. In the following parts we assume that the
disk is a SCSI disk on <path>/dev/sda</path>.
</p>

<p>
Now fire up <c>fdisk</c>:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Deleting All Slices</title>
<body>

<p>
We start with deleting all slices <e>except</e> the 'c'-slice. The following
shows how to delete a slice (in the example we use 'a'). Repeat the process to
delete all other slices (again, except the 'c'-slice).
</p>

<p>
Use <c>p</c> to view all existing slices. <c>d</c> is used to delete a slice.
</p>

<pre caption="Deleting a slice">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
After repeating this process for all slices, a listing should show you something
similar to this:
</p>

<pre caption="Viewing an empty scheme">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Swap Slice</title>
<body>

<p>
On Alpha based systems you don't need a separate boot partition. However, the
first cylinder cannot be used as the <c>aboot</c> image will be placed there.
</p>

<p>
We will create a swap slice starting at the third cylinder, with a total
size of 1 Gbyte. Use <c>n</c> to create a new slice. After creating the slice,
we will change its type to <c>1</c>, meaning <e>swap</e>.
</p>

<pre caption="Creating the swap slice">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
After these steps you should see a layout similar to the following:
</p>

<pre caption="Slice layout after creating the swap slice">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Create the Root Slice</title>
<body>

<p>
We will now create the root slice, starting from the first cylinder <e>after</e>
the swap slice. Use the <c>p</c> command to view where the swap slice ends. In
our example, this is at 1003, making the root partition start at 1004.
</p>

<p>
Another problem is that there is currently a bug in <c>fdisk</c> making it think
the number of available cylinders is one above the real number of cylinders. In
other words, when you are asked for the last cylinder, decrease the cylinder
number (in this example: 5290) with one.
</p>

<p>
When the partition is created, we change the type to <c>8</c>, for <e>ext2</e>.
</p>

<pre caption="Creating the root slice">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Your slice layout should now be similar to this:
</p>

<pre caption="Viewing the slice layout">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Save the Slice Layout and Exit</title>
<body>

<p>
Save <c>fdisk</c> by typing <c>w</c>. This will also save your slice layout.
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your slices are created, you can now continue with <uri
link="#doc_chap9">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#doc_chap8">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using fdisk on SPARC to Partition your Disk</title>
<subsection>
<body>

<impo>
Only users with <e>SPARC</e> based systems should read this section.
</impo>

<p>
The following parts explain how to create the example partition layout described
previously, namely:
</p>

<table>
<tr>
  <th>Partition</th>
  <th>Description</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Boot partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Swap partition</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (required)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Root partition</ti>
</tr>
</table>

<p>
Change your partition layout according to your own will.
</p>


</body>
</subsection>
<subsection>
<title>Firing up fdisk</title>
<body>

<p>
Start <c>fdisk</c> with your disk as argument:
</p>

<pre caption="Starting fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
You should be greeted with the fdisk prompt:
</p>

<pre caption="The fdisk prompt">
Command (m for help):
</pre>

<p>
To view the available partitions, type in <c>p</c>:
</p>

<pre caption="Listing available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Note the <c>Sun disk label</c> in the output. If this is missing, the disk is
using the DOS-partitioning, not the Sun partitioning. In this case, use <c>s</c>
to ensure that the disk has a sun partition table.
</p>

</body>
</subsection>
<subsection>
<title>Deleting Existing Partitions</title>
<body>

<p>
It's time to delete any existing partitions. To do this, type <c>d</c> and hit 
Enter. You will then be prompted for the partition number you would like to 
delete. To delete a pre-existing <path>/dev/hda1</path>, you would type:
</p>

<pre caption="Deleting a partition">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Assuming you want to remove all existing partitions, press <c>p</c> to view the
available partitions, and <c>d</c> to delete those one by one. If you feel like
you made an error, press <c>q</c> immediately -- <c>fdisk</c> doesn't
immediately change the partitions but keeps the changes in memory. Only when you
press <c>w</c> are the partitions saved.
</p>

<p>
After deleting all partitions, you should have a partition layout similar to the
following:
</p>

<pre caption="View an empty partition scheme">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Create the Sun Disk Label</title>
<body>

<p>
Now that the in-memory partition table is empty, we're ready to create the Sun
Disk Label partition. To do this, type <c>n</c> to create a new partition, then 
type <c>3</c> to create the partition. When prompted for the first cylinder, 
hit enter. When prompted for the last cylinder, hit enter. After you've done 
this, type <c>t</c> to set the partition type, and then type in <c>5</c> to set
the partition type to "Whole disk".
</p>

<pre caption="Steps to create a Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Press Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
After completing these steps, typing <c>p</c> should display a partition table 
that looks similar to this:
</p>

<pre caption="View the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Boot Partition</title>
<body>

<p>
We're ready to create a boot partition. To do this, type <c>n</c> to create a 
new partition, then type <c>1</c> to create the partition. When prompted for the
first cylinder, hit enter. When prompted for the last cylinder, type <c>+32M</c>
to create a partition <c>32MB</c> in size. Make sure that the entire boot
partition must be contained entirely within the first 2Gb of the disk. 
You can see output from these steps below:
</p>

<pre caption="Creating a boot partition">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Press Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Now, when you type <c>p</c>, you should see the following partition printout:
</p>

<pre caption="Listing the partition layout">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Creating a swap partition</title>
<body>

<p>
Next, let's create the swap partition. To do this, type <c>n</c> to create a new
partition, then <c>2</c> to create the second partition, <path>/dev/hda2</path>
in our case. When prompted for the first cylinder, hit enter. When prompted for 
the last cylinder, type <c>+512M</c> to create a partition 512MB in size. After 
you've done this, type <c>t</c> to set the partition type, and then type in 
<c>82</c> to set the partition type to "Linux Swap". After completing these 
steps, typing <c>p</c> should display a partition table that looks similar to 
this:
</p>

<pre caption="Listing of available partitions">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Creating the root partition</title>
<body>

<p>
Finally, let's create the root partition. To do this, type <c>n</c> to create a 
new partition, then type <c>4</c> to create the third partition, 
<path>/dev/hda4</path> in our case. When prompted for the first cylinder, hit 
enter. When prompted for the last cylinder, hit enter to create a partition 
that takes up the rest of the remaining space on your disk. After completing 
these steps, typing <c>p</c> should display a partition table that looks similar
to this:
</p>

<pre caption="Listing complete partition table">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Save and Exit</title>
<body>

<p>
To save your partition layout and exit <c>fdisk</c>, type <c>w</c>:
</p>

<pre caption="Save and exit fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Now that your partitions are created, you can now continue with <uri
link="#doc_chap9">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#doc_chap8">Optional: Using
LVM</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Using mac-fdisk on PPC to Partition your Disk</title>
<body>

<p>
At this point, create your partitions using <c>mac-fdisk</c>:
</p>

<pre caption="Starting mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
First delete the partitions you have cleared previously to make room for your
Linux partitions. Use <c>d</c> in <c>mac-fdisk</c> to delete those partition(s).
It will ask for the partition number to delete.
</p>

<p>
Second, create an <e>Apple_Bootstrap</e> partition by using <c>b</c>. It will
ask for what block you want to start. If you previously selected <c>3</c> as
partition number, enter <c>3p</c>.
</p>

<p>
Now create a swap partition by pressing <c>c</c>. Again <c>mac-fdisk</c> will
ask for what block you want to start this partition from. As we used <c>3</c>
before to create the Apple_Bootstrap partition, you now have to enter
<c>4p</c>. When you're asked for the size, enter <c>512M</c> (or whatever size
you want -- 512 is recommended though). When asked for a name, enter <c>swap</c>
(mandatory).
</p>

<p>
To create the root partition, enter <c>c</c>, followed by <c>5p</c> to select
from what block the root partition should start. When asked for the size, enter
<c>5p</c> again. <c>mac-fdisk</c> will interprete this as "Use all available
space". When asked for the name, enter <c>root</c> (mandatory).
</p>

<p>
To finish up, write the partition to the disk using <c>w</c> and <c>q</c> to
quit <c>mac-fdisk</c>.
</p>

<p>
Now that your partitions are created, you can now continue with <uri
link="#doc_chap9">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#doc_chap8">Optional: Using
LVM</uri>.
</p>

</body>
</section>
<section>
<title>Using fdisk on HPPA to Partition your Disk</title>
<body>

<p>
Use <c>fdisk</c> to create the partitions you want:
</p>

<pre caption="Partitioning the disk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO needs a special partition to work. You have to create a partition of at
least 16Mb at the beginning of your disk. The partition type must be of type
<e>f0</e> (Linux/PA-RISC boot).
</p>

<impo>
If you ignore this and continue without a special PALO partition, your system
will stop loving you and fail to start.
</impo>

<p>
Also, if your disk is larger than 2Gb, make sure that the boot partition is in
the first 2Gb of your disk. PALO is unable to read a kernel after the 2Gb limit.
</p>

<p>
Now that your partitions are created, you can now continue with <uri
link="#doc_chap9">Creating Filesystems</uri>, unless you have chosen to use LVM
in which case you should first read <uri link="#doc_chap8">Optional: Using
LVM</uri>.
</p>

</body>
</section>
<section>
<title>Optional: Using LVM</title>
<subsection>
<title>Initialising the Partitions</title>
<body>

<p>
To use LVM, you first need activate LVM and initialise your created partitions. 
To do so, use <c>vgscan</c> (activate LVM) and <c>pvcreate</c> (initialise 
partitions). In this example, we assume that <path>/dev/hda1</path> is a
regular boot partition, <path>/dev/hda2</path> a regular (but small) root 
partition and <path>/dev/hda3</path> a big partition for the LVM.
</p>

<pre caption="Activating and Initialising LVM partitions">
# <i>vgscan</i>
# <i>pvcreate /dev/hda3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Set up the Volume Group</title>
<body>

<p>
Now we need to setup the volume group. We will use <c>vgcreate</c> to do so, but
<c>vgcreate</c> needs the full (DevFS-style) path to the device file. So we
first find out where these devices files are located:
</p>

<pre caption="Getting to know the full location">
# <i>ls -l /dev/hda3</i>
lr-xr-xr-x    1 root     root           33 Oct 21  2003 /dev/hda3 -&gt; ide/host0/bus0/target0/lun0/part3
</pre>

<p>
Now we create the volume group called "vg":
</p>

<pre caption="Create the VG group">
# <i>vgcreate vg /dev/ide/host0/bus0/target0/lun0/part3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Creating the Logical Volumes</title>
<body>

<p>
Now we create the logical volumes. In this example, we create a separate
<path>usr/</path> (10 Gb), <path>home/</path> (5 Gb), <path>opt/</path> (2 Gb),
<path>tmp/</path> (2 Gb), <path>var/</path> (5 Gb) and a swap of 512 Mb.
</p>

<pre caption="Creating the logical volumes">
# <i>lvcreate -L10G -nusr vg</i>
# <i>lvcreate -L5G -nhome vg</i>
# <i>lvcreate -L2G -nopt vg</i>
# <i>lvcreate -L2G -ntmp vg</i>
# <i>lvcreate -L5G -nvar vg</i>
# <i>lvcreate -L512M -nswap vg</i>
</pre>

<p>
As of now, the logical volumes are created and usable as they were regular
partitions:
</p>

<pre caption="Listing the logical volumes">
# <i>ls /dev/vg</i>
home     opt      swap     tmp     usr      var
</pre>

<p>
<e>These</e> files are now your "partitions" (logical volumes).
</p>

</body>
</subsection>
</section>
<section>
<title>Creating Filesystems</title>
<subsection>
<title>Introduction</title>
<body>

<p>
Now that your partitions (and logical volumes if you use LVM) are created, it is
time to place a filesystem on them. If you don't care about what filesystem to
choose and are happy with what we use default in this handbook, continue with 
<uri link="#doc_chap9_sect3">Applying a Filesystem to a Partition</uri>.
Otherwise read on to learn about the available filesystems...
</p>

</body>
</subsection>
<subsection>
<title>Filesystems?</title>
<body>

<p>
Several filesystems are available. Some of them are found stable on all
architectures, others only on a few. The following table lists the available
filesystems and the architectures they are known to work on:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Journaled</th>
  <th>Architectures</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>no</ti>
  <ti>All architectures</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>yes</ti>
  <ti>All</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>yes</ti>
  <ti>x86, hppa, alpha</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>yes</ti>
  <ti>x86, alpha</ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti>yes</ti>
  <ti>x86, alpha</ti>
</tr>
</table>

<p>
<b>ext2</b> is the tried and true Linux filesystem but doesn't have metadata
journaling, which means that routine ext2 filesystem checks at startup time can
be quite time-consuming. There is now quite a selection of newer-generation
journaled filesystems that can be checked for consistency very quickly and are
thus generally preferred over their non-journaled counterparts. Journaled
filesystems prevent long delays when you boot your system and your filesystem
happens to be in an inconsistent state.
</p>

<p>
<b>ext3</b> is the journaled version of the ext2 filesystem, providing metadata
journaling for fast recovery in addition to other enhanced journaling modes like
full data and ordered data journaling. ext3 is a very good and reliable
filesystem. It offers generally decent performance under most conditions.
Because it does not extensively employ the use of "trees" in its internal
design, it doesn't scale very well, meaning that it is not an ideal choice for
very large filesystems, or situations where you will be handling very large
files or large quantities of files in a single directory. But when used within
its design parameters, ext3 is an excellent filesystem.
</p>

<p>
<b>ReiserFS</b> is a B*-tree based filesystem that has very good overall 
performance and greatly outperforms both ext2 and ext3 when dealing with small 
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales 
extremely well and has metadata journaling. As of kernel 2.4.18+, ReiserFS is 
now rock-solid and highly recommended for use both as a general-purpose 
filesystem and for extreme cases such as the creation of large filesystems, the 
use of many small files, very large files and directories containing tens of 
thousands of files. 
</p>

<p>
<b>XFS</b> is a filesystem with metadata journaling that is fully supported 
under Gentoo Linux's xfs-sources kernel. It comes with a robust feature-set and
is optimized for scalability. We only recommend using this filesystem on Linux
systems with high-end SCSI and/or fibre channel storage and a uninterruptible
power supply. Because XFS aggressively caches in-transit data in RAM, improperly
designed programs (those that don't take proper precautions when writing files
to disk and there are quite a few of them) can lose a good deal of data if the
system goes down unexpectedly.
</p>

<p>
<b>JFS</b> is IBM's high-performance journaling filesystem. It has recently 
become production-ready and there hasn't been a sufficient track record to 
comment positively nor negatively on its general stability at this point.
</p>

</body>
</subsection>
<subsection>
<title>Applying a Filesystem to a Partition</title>
<body>

<p>
To create a filesystem on a partition or volume, there are tools available for 
each possible filesystem:
</p>

<table>
<tr>
  <th>Filesystem</th>
  <th>Creation Command</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
For instance, to have the boot partition (<path>/dev/hda1</path> in our
example) in ext2 and the root partition (<path>/dev/hda3</path> in our example)
in ext3 (as in our example), you would use:
</p>

<pre caption="Applying a filesystem on a partition">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Now create the filesystems on your newly created partitions (or logical
volumes).
</p>

</body>
</subsection>
<subsection>
<title>Activating the Swap Partition</title>
<body>

<p>
<c>mkswap</c> is the command that is used to initialize swap partitions:
</p>

<pre caption="Creating a Swap signature">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
To activate the swap partition, use <c>swapon</c>:
</p>

<pre caption="Activating the swap partition">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Create and activate the swap now.
</p>

</body>
</subsection>
</section>
<section>
<title>Mounting</title>
<body>

<p>
Now that your partitions are initialised and are housing a filesystem, it is
time to mount those partitions. Use the <c>mount</c> command. Don't forget to
create the necessary mount directories:
</p>

<pre caption="Mounting partitions">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<p>
We also need to mount the proc filesystem (a virtual interface with the kernel)
on <path>/proc</path>. We first create the <path>/mnt/gentoo/proc</path> 
mountpoint:
</p>

<pre caption="Creating the /mnt/gentoo/proc mountpoint">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
If you are installing Gentoo from a LiveCD, you just need to mount
<path>proc</path>:
</p>

<pre caption="Mounting proc">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
If you are not installing Gentoo from a Gentoo LiveCD, you need to
bindmount <path>/proc</path> and <path>/dev</path>:
</p>

<pre caption="Bind-mounting proc and dev">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
</pre>

<p>
Now continue with <uri link="?part=1&amp;chap=5">Installing the Gentoo
Installation Files</uri>.
</p>

</body>
</section>
</sections>
