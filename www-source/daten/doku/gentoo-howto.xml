<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE guide SYSTEM "http://www.gentoo.org/dtd/guide.dtd">

<!-- English CVS Version 1.31 -->

<guide link="/doc/de/gentoo-howto.html">
<title>Gentoo Linux Entwickler HOWTO</title>
<author title="Autor">
	<mail link="woodchip@gentoo.org">Donny Davies</mail>
</author>
<author title="Autor">
	<mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Autor">
	<mail link="pete@gentoo.org">Peter Gavin</mail>
</author>
<author title="Author">
	<mail link="karltk@gentoo.org">Karl Trygve Kalleberg</mail>
</author>
 <author title="Author">
	<!-- zhen@gentoo.org -->John P. Davis
</author>
<author title="Author">
  	   <mail link="vapier@gentoo.org">Mike Frysinger</mail>
</author>
<author title="Editor">
  	   <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  	   <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  	   <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
 <author title="Editor">
  	   <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  	   <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Übersetzung">
	<mail link="js@ameds.de">Jens Schittenhelm</mail>
</author>

<abstract>
Dieses Dokument ist eine Beschreibung des Gentoo Portage Systems, es erklärt wie man neue Pakete erstellt 
und ist quasi als Standard für die Gentoo Entwickler gedacht. Es ist noch in Arbeit und wird konstant aktualisiert und auf 
keinen Fall vollständig. Die Übersetzung ist ebenfalls unvollständig. Sie sollten dies <e>immer</e> im Zusammenhang mit 
den Manpages von Portage (insbesondere ebuild(5)) und der <uri link="http://www.gentoo.org/doc/en/policy.xml">Gentoo Linux
Development Policy</uri> sehen.
</abstract>

<version>1.4.4</version>
<date> 6. Dezember 2003</date>

<chapter>
	<title>Der Portage Verzeichnisbaum</title>
<section>
	<title>Einführung</title>
<body>

<p>
Der Portage Verzeichnisbaum ist normalerweise unter /usr/portage zu finden und ist hierarchisch 
strukturiert bestehend aus Kategorien gefolgt von Paket-Verzeichnissen. Hier ein Beispiel: Die util-linux-2.11g.ebuild 
Datei ist unter /usr/portage/sys-apps/util-linux zu finden. In diesem Verzeichnis können sich mehrere verschiedene Versionen 
neben dem util-linux-2.11g.ebuild befinden. Alle unterschiedelichen Pakete teilen sich unabhängig von ihrer Version dasselbe 
kategorie/paket Verzeichnis in /usr/portage.
</p>

</body>
</section>
<section>
	<title>Den Portage Verzeichnisbaum mit CVS auschecken</title>
<body>

<p>
Falls CVS noch unbekannt für Sie ist, gibt es das <uri link="http://www.gentoo.org/doc/en/cvs-tutorial.xml">CVS Tutorial</uri>.
Der Portage Verzeichnisbaum befindet sich im gentoo-x86 Paket des Gento Linux Verzeichnisbaumes. Um das ganze (doch recht 
grosse) Paket auszuchecken, sollte mit Hilfe obiger Anleitung CVS eingerichtet werden und dann der gentoo-x86 Verzeichnisbaum
ausgecheckt werden.
</p>

</body>
</section>
<section>
	<title>Was gehört nicht in den Portage Verzeichnisbaum?</title>
<body>

<p>
Befor ein ebuild geschrieben wird, sollte in <uri link="http://bugs.gentoo.org">bugs.gentoo.org</uri> nachgeschaut werden, 
ob sich nicht jemand anderes bereits die Mühe gemacht hat, das ebuild zu schreiben, welches aber noch nicht in den offiziellem
Portage Verzeichnisbaum übernommen wurde. Dabei sollte wie folgt vorgegangen werden: Auf der 
<uri link="http://bugs.gentoo.org">bugs.gentoo.org</uri> "query" auswählen, als Produkt "Gentoo Linux" markieren, als Component
"ebuild" auswählen. Im Suchfeld dann den Namen des ebuilds eingeben, sowie als Status NEW, ASSIGNED, REOPENED und (wichtig!) 
RESOLVED markieren, dann die Suchabfrage starten.
</p>
			
<p>
Generell sollte im Portage Verzeichnis nur die .ebuild Dateien und sehr kleine zugehörige Dateien, wie 
zum Beispiel Patches oder Beispielskonfigurationen gespeichert werden. Diese Dateien sollten immer unter 
/usr/portage/kategorie/paket/files abgespeichert werden, um das kategorie/paket Verzeichnis nicht zu 
unübersichtlich machen. Generell ist es für Entwickler keine gute Idee Binärdateien (Nicht-ASCII-Dateien) 
im CVS abzulegen. Wenn dies dennoch notwenig sein sollte (zum Beispiel eine PNG Grafik aus welchem 
Grund auch immer), dann sollte sie mit der -kb option in das CVS eingebracht werden:

<pre caption="Code Auflistung 1">
# cvs add -kb myphoto.png</pre>

Die -kb option teilt CVS mit, dass myphoto.png eine Binärdatei ist und einer besonderen
Behandlung bedarf. Zum Beispiel das Zusammenführen von zwei verschiedenen Binärdateien wird somit nicht erlaubt,
was hier auch naheliegend ist. Wenn wir schon beim Zusammenführen sind, alle Patches die dem Portage Verzeichnisbaum
hinzugefügt werden, sollten nicht komprimiert sein. Dies erlaubt dann CVS Veränderungen einzubringen und die Entwickler 
von dabei möglicherweise entstehenden Konfliken korrekt zu warnen.
</p>
		
<p>
Nochmals zur Erinnerung: Die Pakete, die in CVS als stable eingecheckt werden, solten wirklich ohne Einschränkungen 
funktionieren. Es sollte sichergestellt werden, dass ein guter Satz an Standardeinstellungen gewählt wurde, der auf der Mehrheit
aller Systeme laufen wird und somit die Benutzer zufrieden stellt. Wenn das Paket Probleme bereitet, oder Sie nicht sicher sind,
wie es zum Laufen gebracht werden kann, hilft sicher ein Blick auf andere Distributionen, welche meistens ihre eigene Fassung
des Paketes besitzen. Gute Beispiele sind hier <uri link="http://cvs.mandrakesoft.com/cgi-bin/cvsweb.cgi/SPECS/">Mandrake</uri>
oder <uri link="http://www.debian.org/distrib/packages">Debian</uri>.
</p>

<p>
Beim Einchecken der ebuilds im CVS sollten alle Entwickler <c>repoman commit</c> statt <c>cvs commit</c> verwenden. 
Vor Ausführung des commit sollte mit <c>repoman full</c> sichergestellt werden, dass nichts vergessen wurde.
 </p>

</body> 	
</section>
 <section>
	<title>Allgemeine CVS Commit Regeln</title>
<body>

<p>
  <ul>
  <li>Vor einem commit immer <c>repoman scan</c> ausführen</li>
   <li>Bitte <c>repoman full</c> vor dem commit ausführen</li>
   <li>Immer testen, ob <path>package.mask</path> in Ordnung ist, indem mit <c>emerge --pretend glibc</c> mögliche Konflikte angezeigt werden</li>
   <li>Immer das <path>ChangeLog</path> vor dem commit aktualisieren!</li>
   <li>Um sicherzugehen, das Konflikte während dem CVS commit keine schwerwiegenden Auswirkungen auf den Portage Verzeichnisbaum
   auftreten, sollte immer vor dem commit des eigentlichen ebuilds, das aktualisierte package.mask eincheckt werden.</li>
   <li>Bitte sauber einchecken! Zuerst das aktualisierte <path>package.mask</path>, dann das ebuild, <path>ChangeLog</path> und die 
   Lizenz in einem Zug, da ansonsten die Benutzer bei ihren Installationen Probleme bekommen.</li>
</ul>
</p>

</body>
</section> 
<section>
	<title>Das files Verzeichnis</title>
<body>

<p>
Wie vorher bereits beschrieben, existiert in jedem paket Unterverzeichnis das Verzeichnis files. 
Alle Patches, Konfigurationsdateien oder andere Dateien, die von diesem Paket gebraucht werden, gehören 
hier hinein. Selbst erstellte Patches sollten mit einem Versions-Namen versehen werden, wie zum beispiel 
meinpaket-1.0-gentoo.diff. Die Gentoo Erweiterung im Namen informiert die Benutzer, dass dieser Patch durch
uns, den Gentoo Entwicklern, erstellt wurde und nicht aus einer Mailingliste oder sonst wo gezogen wurde. 
Auch hier sollten die  diffs nicht komprimiert werden, da CVS mit Binärdateien nicht so gut umgehen kann.
</p>
		
<p>
Es sollte immer ein Suffix, wie z.b. mypkg-1.0 an das Ende jeder Datei gesetzt werden, die in das files Verzeicnis
gehören, um die einzelnen Dateien unmissverständlich den einzelnen ebuild Skripten zuzuordnen können und die Unterschiede
zwischen den einzelnen diffs sichtbar werden. Dies ist generell eine gute Sache :-) Natürlich kann, wenn genauere
Unterscheidung benötigt wird, ein anderes Suffix verwendet werden.
</p>

<p>
Bei einer grösseren Anzahl von Dateien empfiehlt es sich ein Unterverzeichnis wie z.B. files/mypkg-1.0 anzulegen
und die jeweiligen zugehörigen Dateien hier hineinzukopieren. Bei dieser Methode kann man natürlich auf das Suffix
bei den einzelnen Dateien verzichten, da dies bereits aus dem Verzeichnisnamen hervorgeht. Das spart einiges an Arbeit.
</p>

</body>
</section>
</chapter>	

<chapter>
	<title>Die ebuild Skripte</title>
<section>
	<title>Einführung</title>
<body>

<p>
Die ebuild Skripte bilden die Grundlage des gesamten Portage Systems. Sie enthalten die gesamte Information
zum Herunterladen, Entpacken, Kompilieren und Installieren des Quellcodes, aber auch eventuelle Änderungen und 
Konfigurationen, die vor oder nach der Installation oder beim Entfernen durchgeführt werden. Während das meiste
von Portage in Python geschrieben ist, sind die ebuilds als bash-Skripte gehalten, da dies das Aufrufen von Befehlszeilen
wie auf der Kommandozeile ermöglicht. Eines der Hauptdesign-Prinzipien der ebuild Skripte ist, dass die darin aufgerufenen
Befehle denen der Kommandozeile entsprechen, wie wenn der Benutzer das Paket manuell installieren würde. Aus diesem
Grund ist die bash-Syntax eine gute Wahl.
</p>

<p>
Ebuild Skripte werden durch die <c>ebuild</c> und <c>emerge</c> Befehle ausgeführt. Man muss sich das 
<c>ebuild</c> Kommando als einfaches Handwerkzeug vorstellen. Es kann ein ebuild erstellen und installieren, 
aber mehr auch nicht. Es kontrolliert, ob Abhängigkeiten erfüllt sind, kann diese aber nicht selbständig auflösen. Auf
der anderen Seite ist <c>emerge</c> als hochspezialisierte Zentrale für <c>ebuild</c>, welches die Möglichkeit 
besitzt, selbständig abhängige Pakete zu installieren, wenn gewünscht als "was wäre wenn..." dem Benutzer anzeigen,
welche ebuilds eingeführt <e>würden</e> und vieles mehr. Allgemein sticht <c>emerge</c> den <c>ebuild</c> Befehl
in allen Belangen aus, bis auf einen Punkt. Mit <c>ebuild</c> kann der Benutzer inkrementell alle unterschiedlichen
Bereiche einer Paketinstallation (herunterladen, entpacken, kompilieren, installieren und einführen) Schritt für Schritt  
ausführen. Für Entwickler ist dies ein unverzichtbares Werkzeug zum debuggen, da nur so Probleme mit dem ebuild
auf einen kleinen Bereich des Gesamtprozesses eingegrenzt werden können.
</p>
</body>
</section>

<section>
	<title>Die Benennung von  ebuild Dateien</title>
<body>

<p>
Jeder Ebuild Dateiname besteht aus vier Abschnitten:
</p>

<p>
Der erste Abschnitt ist der Paketname, der nur aus Kleinbuchstaben, den Zahlen 0-9 und dem Bindestrich ('-')
enthalten darf. Beispiele sind: <c>util-linux</c>, <c>sysklogd</c> und <c>glibc</c>.  
</p>

<p>
Der zweite Abschnitt ist die Versionsnummer des Paketes, welche normalerweise mit der Versionsnummer des
Quellcode Tarballs übereinstimmt. Diese besteht normalerweise aus zwei oder drei Nummern, die durch Punkte
von einander getrennt sind, wie zum Beispiel <c>1.2</c> oder <c>4.5.2</c> (sehr lange, durch Punkte
voneinander getrennte Nummern werden auch unterstützt) und darf von einen einfachen Buchstaben auf die letzte
Zahl gefolgt werden, zum Beispiel: <c>1.4b</c> oder <c>2.6h</c>. Die Paketnummer wird mit der Versionsnummer
durch einen Bindestrich verbunden: <c>foo-1.0</c>, <c>bar-2.4.6</c>, etc.
</p>

<impo>
Wenn Sie mit dem Gedanken spielen, einen angehängten Buchstaben in Ihrer Versionsnummer zu verwenden,
sollten Sie darüber im klaren sein, dass dieser Buchstabe <e>nicht</e> dazu verwendet werden sollte, einen
eventuellen Alpha oder Beta Status anzuzeigen, da alphas und betas als <e>prereleases</e> zählen, angehängte
Buchstaben jedoch als <e>neuere Versionen</e>. Das ist eine grosse Unterscheidung, da Portage die Versionsnummer eines
ebuilds dazu verwendet, herauszufinden, ob es neuer oder älter ist als ein Paket mit gleichem Namen aus derselben
Kategorie. Es ist sehr wichtig, dass Versionsnummern glaubwürdig die Version eines Paketes repräsentieren, damit
Portage seine Abhägigkeits-Prüfungen korrekt ausführt.
</impo>

<p>
Der dritte Abschnitt (optional) enthält eine spezielle Suffix, entweder <c>_alpha</c>, <c>_beta</c>, <c>_pre</c> oder 
<c>_rc</c>. Alle diese Suffixe werden durch eine Nummer ergänzt, zum Beispiel <c>linux-2.4.0_pre10</c>. Bei identischen
Versionsummern geht Portage davon aus, dass <c>_alpha</c> älter als <c>_beta</c> ist, <c>_beta</c> älter als <c>_pre</c>
und <c>_pre</c> äter als <c>_rc</c> ist.
</p>

<note>
Ein <c>_rc</c> Paket ist älter als ein Paket ohne vorausgehende  Suffixe mit Unterstrich (z.B. <c>linux-2.4.0</c>)
und <c>linux-2.4.0</c> ist älter als ein Paket mit einem Buchstaben Präfix, hier <c>linux-2.4.0b</c>. Nochmal: Diese 
Versionsinformationen sind wichtig, da Portage es zur Bestimmung heranzieht, ob ein Paket oder ebuild älter oder jünger ist,
als ein Paket aus der selben Kategorie mit gleichem Namen.
</note>

<p>
Der vierte Abschnitt (ebenfalls optional) ist die Gentoo Linux spetzifische <e>Revisionsnummer</e>, welche durch <c>-r#</c>
angegeben wird, wobei <c>#</c> ein Integer (Zahlenwert) ist, als Beispiel: <c>package-4.5.3-r3</c>. Die Revisionsnummer ist
unabhängig von der Versionsnummer des Quellpaketes und kann dazu genutzt werden, die Benutzer davon in Kennntnis zu setzen, 
dass es sich um ein neues bzw. erweiterte Revision eines ebuilds handelt.
</p>

<p>
Wenn grössere Veränderungen an einem bestehenden ebuild vorgenommen werden, sollte die Datei vorher kopiert und mit einer
um 1 erhöhten Revisionsnummer abgespeichert werden. Die ersten Fassungen besitzen normalerweise keine Revisionsnummer, z.B.
<path>package-4.5.3</path>, da sie von Portage so betrachtet werden, als ob sie eine Revisionsnummer von Null haben. Das 
bedeutet für die Zählweise: <c>1.0</c> (erste Version), <c>1.0-r1</c>, <c>1.0-r2</c>, und so weiter. Denken Sie daran, die
von Ihnen vorgenommenen Veränderungen im ChangeLog zu dokumentieren. Sie bekommen sonst ernste Probleme mit uns,
wenn Sie nicht <e>jedes mal</e> Ihre Änderungen im <path>ChangeLog</path> notieren. Ansonsten kann Ihr CVS Zugang
wieder entzogen werden.
</p>

<p>
Und natürlich gehen wir davon aus, dass der <e>fünfte</e> Abschnitt der ebuild Bezeichnung nicht vergessen wird,
es ist die <c>.ebuild</c> Endung.
</p>
	</body>
</section>

<section>
	<title>Aufbau einer ebuild Datei</title>
<body>

<note>
Dieser Abschnitt ist eine Einführung in die Ebuilds. Für eine komplette Auflistung aller Möglichkeiten in einem Ebuild haben wir die Manpage,
welche die interne Formatierung, Variablen und Funktionen eines Ebuild Skriptes erläutert: <c>man 5 ebuild</c>.
</note>

<p>
Variablen:
</p>

<p>
Der Anfang jeder ebuild Datei besteht aus einigen Variablen, welche in eine der drei folgenden Kategorien fallen (und mit diesen versehen sind):
</p>

<p>
<ul>
 <li>READ: Variablen, die Sie verwenden können, aber <e>niemals</e> setzen</li>
 <li>MUST: Variablen, die Sie<e>immer setzen müssen</e></li>
 <li>OPT: Variablen, die Sie setzen sollten</li>
 </ul>
</p>

<!-- Translation & Review stops here -->
	<table>
         <tr><ti><c>P</c></ti><ti>Der Name und die Versionsnummer des Paketes, dies muss normalerweise nicht gesetzt werden, da es von 
         Portage durch den Dateinamen bestimmt wird</ti></tr>
         <tr><ti><c>A</c></ti><ti>Der Name ohne Pfadangabe von dem Haupt-Quellcode des Paketes</ti></tr>
         <tr><ti><c>S</c></ti><ti>Das Quellcode-Verzeichnis für das Paket, im Normalfall${WORKDIR}/${P}</ti></tr>
         <tr><ti><c>DESCRIPTION</c></ti><ti>Eine kurze Beschreibung des Paketes in einem Satz</ti></tr>
         <tr><ti><c>SRC_URI</c></ti><ti>sind die URIs für jede Quellcode-Datei in diesem Paket, welche durch Leerzeichen getrennt werden. 
         Das Erste ist normalerweise so etwas wie: <e>ftp://ftp.company.com/pub/somepackage/${A}</e></ti></tr>
         <tr><ti><c>HOMEPAGE</c></ti><ti>ist die Homepage des Pakets</ti></tr>
         <tr><ti><c>DEPEND</c></ti><ti>build Abhängigkeiten, siehe dazu den Abschnitt <uri link="#dependencies">Package Dependencies</uri></ti></tr>
         <tr><ti><c>RDEPEND</c></ti><ti>runtime Abhängigkeiten. mehr dazu im Abschnitt <uri link="#dependencies">Package Dependencies</uri></ti></tr>
        </table>
        
 <p>
2. ebuild Funktionen
</p>
 
<p>
Es gibt verschiedene Funktionen, die ein den ebuild Dateien definiert werden können, um den Prozess der Zusammenstellung und Installation
des Paketes steuern zu können.
</p>

	<table>
	<tr><ti><c>pkg_setup</c></ti><ti>mit dieser Funktion können vorbereitende Schritte durchgeführt werden. Dazu gehört die Kontrolle des 
	Benutzerkontos oder die Kontrolle nach einer existierenden Konfigurationsdatei. Diese Funktion muss den Wert 0 zurückgeben, damit
	das ebuild fortgesetzt werden kann.</ti></tr>
	<tr><ti><c>pkg_nofetch</c></ti><ti>Informiert den Benutzer über Aktionen oder Downloads, die er selbst ausführen muss (z.B. aus 		
	Lizenzierungsgründen).</ti></tr>
        <tr><ti><c>src_unpack</c></ti><ti>Mit dieser Funktion kann der Quellcode entpackt werden und autoconf/automake/etc. ausgeführt werden.
	Standardmässig wird das Paket in <c>${A}</c> entpackt. Das Standard-Startverzeichnis ist  <c>${WORKDIR}</c>.</ti></tr>
	<tr><ti><c>src_compile</c></ti><ti>Damit wird das Paket konfiguriert und kompiliert. Das Standard-Startverzeichnis ist <c>${S}</c>.</ti></tr>
	<tr><ti><c>src_install</c></ti><ti>Mit dieser Funktion wird das Paket in <c>${D}</c> installiert. Benutzt das Paket automake, kann dies
	mit <c>make DESTDIR=${D} install</c> vereinfacht werden. <e>Es sollte sichergestellt werden, dass die Installation aller Dateien in <c>${D}</c>
	als root ausgeführt wird!</e></ti></tr>
	<tr><ti><c>pkg_preinst</c></ti><ti>Die Befehle in dieser Funktion werden vor dem mergen der Dateien ausgeführt.</ti></tr>
	<tr><ti><c>pkg_postinst</c></ti><ti>Die Befehle in dieser Funktion werden nach dem mergen der Dateien ausgeführt.</ti></tr>
	<tr><ti><c>pkg_prerm</c></ti><ti>Die Befehle in dieser Funktion werden vor dem Entfernen der Dateien ausgeführt.</ti></tr>
	<tr><ti><c>pkg_postrm</c></ti><ti>Die Befehle in dieser Funktion werden nach dem Entfernen der Dateien ausgeführt.</ti></tr>
	<tr><ti><c>pkg_config</c></ti><ti>Mit dieser Funktion kann die initiale Konfiguration des Paketes nach der Installation ausgeführt werden. Alle
	Pfade in dieser Funktion sollen mit dem Prefix ${ROOT} versehen werden. Diese Funktion wird <e>nur</e> ausgeführt, wenn der Benutzer folgenden
	Befehl ausführt: <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>.</ti></tr>
        </table>

<p>
Folgende Funktionen können ebenfalls im ebuild verwendet werden:
</p>

	<table>
	<tr><ti><c>use</c></ti><ti>Kontrolle ob, eine oder mehere gegebenen USE-Flags gesetzt sind. Ist dies der Fall, wird die Funktion die
	USE-Flag zurückgeben. Zur Kontrolle der Existenz einer solchen Flag kann <c>[ -z "`use foobar`"]</c> ausgeführt werden.</ti></tr>
	<tr><ti><c>has_version</c></ti><ti>Gibt 1 zurück, wenn auf dem System die geforderte version installiert ist. Als Beispiel: 
	<c>has_version >=glibc-2.3.0</c>.</ti></tr>
	<tr><ti><c>best_version</c></ti><ti>Gibt <i>category/package-version</i> des jeweiligen Pakets zurück. Beispiel: 
	<c> best_version x11-libs/gtk+extra</c>.</ti></tr>
	<tr><ti><c>use_with</c></ti><ti> Diese Funktion prüft ob eine USE-Flag gesetzt wurde und gibt enstprechend "--with-foobar" oder 
	"--without-foobar" zurück. Bei einem Argument ist dieses sowohl der USE-Flag und der with(out) String. Andernfalls ist das erste
	Argument der USE-Flag und das zweite Argument der with(out) String. Beispiel: <c>use_with truetype freetype</c></ti></tr>
	<tr><ti><c>use_enable</c></ti><ti>Hat die gleiche Funktion wie use_with, gibt jedoch "--enable foobar" oder "--disable foobar" 
	zurück.</ti></tr>
	<tr><ti><c>check_KV</c></ti><ti>Prüft ob Portage die Kernel-Versionsnummer erkennt. Ist dies nicht der Fall wird eine Fehlermeldung
	ausgegeben und das ebuild abgebrochen. Wenn im Script die Versionsnummer geprüft werden soll, kann <c>${KV}</c> verwendet werden, 
	welche automatisch durch Portage definiert wird.</ti></tr>
	<tr><ti><c>keepdir</c></ti><ti>Erstellt ein .keep Datei im gegebenen Verzeichnis, so dass dies nicht automatisch von Portage
	wieder entfernt werden kann.</ti></tr>
	<tr><ti><c>econf</c></ti><ti>Führt <c>./configure</c>mit den notwendigen Pfadänderungen (Prefix,host, mandir, infodir, datadir, 
	sysconfdir, localstatedir) durch. Optionale Argumente für <c>./configure</c>können gesetzt werden.</ti></tr>
	<tr><ti><c>einstall</c></ti><ti>Führt ein <c>make install</c> durch, sodass Portage weiss, wohin die Dateien installiert werden.</ti></tr>
	<tr><ti><c>die</c></ti><ti>Bricht den aktuellen Prozess ab. Das übergebene Argument wird dem Benutzer als Nachricht dargestellt.</ti></tr>
	<tr><ti><c>einfo</c></ti><ti>Kann verwendet werden, um den Benutzer über wichtige Dinge zu informieren. Das Argument das an <c>einfo</c> 
	übergeben wird, ist die Nachricht, die der Benutzer erhält.</ti></tr>
	</table>

</body>
</section>
<section>
	<title>Regeln zum Schreiben eines ebuilds</title>
<body>

<p>
a ebuilds in Wirklichkeit nur aus einfachen Shell Skripten bestehen, sollte der zu bearbeitende Editor auf diesen Modus eingestellt
	werden. Korrektes Einrücken sollte beachtet werden, nur Tab-Sprünge und keine Leerzeichen. Am besten den Editor so einstellen, dass die
	Tabulatorsprünge alle vier Leerzeichen gesetzt sind. Die Klammern um die Umgebungsvariablen sollten nicht vergessen werden; d.h. <c>${P}</c>
	anstatt nur <c>$P</c>.</p>

	<p> Längere Zeilen sollten mit '\' umgebrochen werden:
	<pre caption="Code Auflistung 2.1">
	./configure \
	--prefix=/usr || die "configure failed"</pre>
	Für weitere Details kann man einen Blick in <i>skel.ebuild</i> werfen, dies befindet sich in /usr/portage.</p>
	
	<p>Bei der Benutzung von Vim kann folgender Code am Ende der .vimrc Datei eingetragen werden, damit sind automatisch alle Einstellungen
	für Gentoo-Dokumente gesetzt.
	<pre caption="Code Auflistung 2.2">
	if (getcwd() =~ 'gentoo-x86\|gentoo-src\|portage')
	set tabstop=4 shiftwidth=4 noexpandtab
	endif</pre>
	</p>

	<p>Bei der Benutzung von emacs kann in das .emacsrc (GNU Emacs) oder in die init.el (XEmacs) eingetragen werden.
  	<pre caption="Code Auflistung 2.3">
	(defun ebuild-mode ()
  	(shell-script-mode)
	  (sh-set-shell "bash")
	  (make-local-variable 'tab-width)
	  (setq tab-width 4))
	(setq auto-mode-alist (cons '("\\.ebuild\\'" . ebuild-mode) auto-mode-alist))
	(setq auto-mode-alist (cons '("\\.eclass\\'" . ebuild-mode) auto-mode-alist))</pre></p>
	</body>
</section>

<section>
	<title>Die USE Variablen</title>
	<body><p>Die USE-Variablen dienen dem Zweck, Portage global zu konfigurieren und automatisch bestimmte Kompilierungsoptionen an- oder abzuschalten.
	Hier ist ein Beispiel. Wir gehen nun davon aus, dass Sie ein GNOME-Fan sind, und jedes ebuild, welches eine optionale GNOME Unterstützung anbietet, soll 
   	dies automatisch miteinkompilieren. In diesem Fall fügen wir <c>gnome</c> in die USE variable von <i>/etc/make.conf</i> hinzu und Portage berücksichgt dies
	bei jeder Kompilierung eines Paketes mit GNOME Unterstützung. Im umgekehrten Fall, wenn optinale GNOME Funktionen nicht gewünscht sind, editiert man
	/etc/make.conf und stellt sicher, dass <c>gnome</c> in der USE Variable nicht gesetzt ist. Gentoo Linux besitzt eine überwältigende Anzahl von USE Optionen,
	die es Ihnen erlauben, das System genau so zu konfigurieren, wie Sie es haben möchten.</p>

	<p><note> Wenn eine USE Variable deaktiviert ist (hier im Beispiel <c>gnome</c>) wirk sich dies nur auf die <i>optinalen</i> Kompilierungsoptionen aus. Wenn 
	Sie jedoch ein ebuild <c>emergen</c>, welches auf ein GNOME Paket angewiesen ist, wird GNOME automatisch als eine Abhängigkeit hiervon mitinstalliert,
	falls es nicht bereits erfolgt ist. Das ist auch der Grund, weshalb man vor dem eigentlichen <c>emerge</c> ein <c>emerge --pretend</c> ausführen sollte. In
	so einem Fall wissen Sie bereits vorher Bescheid, was alles auf Ihrem System installiert wird.</note></p>

	<p>In Ihren eigenen ebuilds kann mit Hilfe der USE Variable geprüft werden, ob die entsprechende Variable vom Besitzer der Installation bereits gesetzt ist. Das 
	<c>use</c> Kommando gibt den Namen jeder Variable zurück, die USE und seiner Befehlszeile präsent ist. Der Befehl wird normalerweise so angewendet:</p>
	
	<p><c>if [ "`use X`" ]; then commands; fi</c></p>

	<p>USE Variablen können auch dazu verwendet werden, bestimmte Abhängigkeiten zu setzen. In unserem Beispiel wollen wir ein bestimmtes Paket nur
	dann als erforderlich markieren, wenn eine bestimmte USE Variable gesetzt ist. Dies kann mit folgender Syntax durchgeführt werden: <c>variable? 
	(mycat/mypackage-1.0-r1)</c> in der DEPEND Zeile Ihres ebuilds. In diesem Fall wird <c>mycat/mypackage-1.0-r1</c> nur dann erforderlich, wenn
	die entsprechende Variable in den USE vorhanden ist. Umgekehrt ist es auch möglich, festzulegen, welche weitere Abhängigkeit verwendet werden soll, wenn
	eine USE-Flag <i>nicht</i> gesetzt ist: <c> variable? (mycat/mypackage-1.0-r1) : (othercat/otherpackage-1.0-r5)</c>. In diesem Fall wird dann das
	Paket <c>othercat/otherpackage-1.0-r5</c> anstatt von <c>mycat/mypackage-1.0-r1</c> installiert. Soll ein Abhängigkeit nur dann installiert werden,
	wenn die Variable nicht vorhanden ist, verwendet man <c>!variable? (mycat/mypackage-1.0-r1)</c>. Es sollte sichergestellt werden, dass nur die oben
	genannte Syntax verwendet wird und nicht die Bash eigene "ifs". Bash Bedingungen stören Portages Abhängigkeits-Cache, sodass die Verwendung dieser
	zu einem funktionsunfähigem ebuild führen wird.</p>

	<p>Hier noch ein wichtiger Tipp zur Verwendung von <c>USE</c>. In dem meisten Fällen besitzt das Paket bereits ein <c>./configure</c> Skript um 
	das Paket zu konfigurieren. Optionale Bestandteile werden durch Übergabe bestimmer Argumente zur Laufzeit mitkompiliert. Zur Übergabe der USE-Flags
	an das Konfikurationsskript geht man am besten wie folgt vor: Zunächst sollte herausgefunden werden, ob eine bestimmte <c>./configure</c> Option
	standardmässig ein- oder abgeschaltet ist.</p>

	<pre caption="Code Auflistung 2.4"> 
	DEPEND="X? ( >=x11-base/xfree-4.3 )
	        mysql? ( >=dev-db/mysql-3.23.49 )
	        apache2? ( >=net-www/apache-2 ) : ( =net-www/apache-1.* )"

	src_compile() {
    		local myconf
		use X || myconf="--disable-x11"
		use mysql || myconf="${myconf} --disable-mysql"

	    ./configure ${myconf} --prefix=/usr --host=${CHOST} || die
	    emake || die
	}
	</pre>

	<p>Im obigen Beispiel prüfen wir, ob die X und mysql USE Variablen abgeschaltet sind. Der Abschnitt <c>use X ||</c> kontrolliert, ob X in der USE Variable
	vorhanden ist. Ist dies nicht der Fall, so übergibt er das Argument <c>myconf="--disable-x11"</c> an das Konfigurationsskript. Es ist nicht notwendig X11
	und mysql explizit zu aktivieren, da diese standardmässig bereits eingeschaltet sind. Wenn jedoch eine bestimmte Option standardmässig abgeschaltet ist
	kann man wie folgt vorgehen:</p>

	<pre caption="Code Auflistung 2.5"> 
	DEPEND="X? ( >=x11-base/xfree-4.3 )
	        mysql? ( >=dev-db/mysql-3.23.49 )"

	src_compile() {
	    local myconf
	    use X &amp;&amp; myconf="--enable-x11"
	    use mysql &amp;&amp; myconf="${myconf} --enable-mysql"
	
	    ./configure ${myconf} --prefix=/usr --host=${CHOST} || die
	    emake || die
	}
	</pre>
	
	<p>In diesem Beispiel werden X11 und MySQL-Unterstützung nur dann explizit aktiviert, wenn die entsprechende USE Variable vorhanden ist. Der Abschnitt
	<c>use mysql &amp;&amp;</c> prüft, ob mysql in der USE-Flag gesetzt ist, und übergibt dann <c> myconf="${myconf} --enable-mysql"</c>.</p>

	<p>Eine kontnuierlich aktualisierte Liste aller USE Variablen fidnet mann <uri link="http://www.gentoo.org/dyn/use-index.xml">hier</uri>.
       </p></body>
</section>
</chapter>

<chapter>
	<title>Aufbau des Dateisystems</title>

<section>
	<title>Einführung in FHS</title>
	<body>
	<p>Der Aufbau des Gentoo Linux Dateisystems orientiert sich am am FHS Standard, kurz für: <i>Filesystem Hierarchy Standard</i>. Eine kurze 
	Beschreibung dieses Standards wir hier gegeben, eine komplette Spezifikation findet man unter <uri link="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/
	</uri>.
	</p>

	<p><note>Der /opt Breich wird in Abschnitt 3.12 der FHS Spezifikation beschrieben. Abschnitt 4.4 behandelt das /usr/X11R6 Verzeichnis. KDE und GNOME werden
	nicht spezifisch besprochen und sind in der aktuellen Fassung des FHS überhaupt nicht berücksichtigt.</note>
	</p></body>
</section>


<section>
	<title>Wohin mit meinem Paket in diesem Dateisystem?</title>
	<body>
	<p>Normalerweise wird bei der Verwendung von autoconf und automake das Paket standardmässig korrekt installiert, allerdings mit einigen wenigen
	Ausnahmen:
	<ul>
	<li>Wenn das Programm nach /bin, /sbin, /usr/bin oder /usr/sbin installiert wird, sollten die dazugehörigen Man-Pages nach /usr/share/man kopiert werden.
	Dies kann meistens durch Übergabe des Arguments <c>./configure --mandir=/usr/share/man</c> im ebuild Skript bewerkstelligt werden.</li>
	<li>GNU Info Dateien gehören nach /usr/share/info, <i> auch wenn die Info-Dateien X11, GNOME oder KDE-Programme betreffen</i>. Nochmals:
	/usr/share/info ist der <i>einzige</i> offizielle Platz für GNU Info-Dateien! Leider instellieren die meisten ./configure Skripte die GNU Dateien nach
	/usr/info, sodass man mit Hilfe des <c>--infodir=/usr/share/info</c> Arguments nachhelfen muss.</li>
	<li>Dokumentationen werden in ein Unterverzeichnis von /usr/share/doc installiert. Dies sollte Namen, Version und Revisionsnummer des betreffenden
	Programmes beinhalten. Das gilt für alle Programme, GNOME, KDE, X11 wie auch der Konsole. Manchmal wird weitere Dokumentation für 
	spezielle Zwecke in die /usr/shareHierarchy eingebunden.</li>
	<li>X11-spezifische Programme und Bibliotheken sollten immer nach /usr installiert werden und nicht direkt nach /usr/X11R6, welches ausschliesslich
	für das X Window System, Version 11 Release 6 vorbehalten ist. Dies ist wahrscheinlich einer genauere Interpretation der FHS Spezifikation, als
	es in anderen Distributionen üblich ist.</li>
	<li>GNOME und KDE Programme gehören ebenfalls nach /usr.</li>
	</ul></p>

	<impo>Manche Distributionen installieren KDE und GNOME nach /opt. Zur Zeit existiert kein Standard für die Installtion von Dateien der Desktop-Umgebungen.
	Im Interesse einer einfachen und konsistenten Handhabung haben wir uns entschieden, alle KDE und GNOME Pakete nach /usr zu installieren.</impo>

	<p>Generell sollte das ebuild seine Dateien in den /usr Verzeichnisbaum installieren. Manche Programme können mit oder ohne GNOME; KDE und X11
	Bibliotheken kompiliert werden, was für verwirrung sorgt. Unsere Lösung, alles nach /usr zu installieren, verhindert doppelte Arbeit und unnötige Komplexität
	für die ebuild Entwickler. Der Pfad, in den die Programmdateien installiert werden, sollte nicht an das Vorhandensein oder Fehlen von USE Variablen
	geknüpft werden. Somit installieren die ebuilds im Portage Verzeichnisbaum in fast allen Fällen ihre Dateien nach /usr.</p>

	<p><note>Das /opt Verzeichnis in Gentoo Linux ist für binäre Pakete reserviert. Als Beispiele können hier mozilla-bin, acroread und realplayer angeführt
	werden. Die hierhin installierten Pakete benötigen in der Regel eine /etc/env.d/foo Markierungsdatei. Dies dient der Möglichkeit, Pfade und zusätzliche
	Variablen der Laufzeitumgebung hinzuzufügen können.</note></p>
	</body>
</section>
</chapter>
<chapter>
<title>The Portage scripts and utilities</title>
<section>
<title>Public scripts</title>
<body>

<p>
These are scripts used by the system-administrator to install and remove 
packages, and maintain the package database.
</p>

<p>
<c>ebuild</c> is the main engine of the Portage system; it performs all major 
tasks such as unpacking, compiling, installing, merging, and unmerging 
packages.  It is called using the command: <c>ebuild path/to/package.ebuild
command</c>.  The commands available are:
</p>

<table>
<tr>
  <th>Command</th>
  <th>Description</th>
  <th>Related <c>ebuild</c> Function</th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Performs any miscellaneous commands required before the ebuild can proceed
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Displays the dependencies required to build the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Unpacks, compiles, installs, and merges the package into your file system
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Merges the package into your file system, assuming that the the unpack, 
    compile, and install stages have already been executed
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Unpacks the source tarballs into the work directory
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Compiles the package</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Creates an RPM from the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Creates a Gentoo <c>tbz2</c> package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Executes the pre-removal stage of the package</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Executes the post-removal stage of the package</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Executes the pre-installation stage of the package</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Executes the post-installation stage of the package</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Sets up a default configuration once the package is merged</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Updates the mtimes for each source archive in the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Cleans the work directory for the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Fetches the package source tarballs</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Creates a digest file for the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Installs the package into the image directory</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Unmerges the package from your file system</ti>
  <ti>N/A</ti>
</tr>
</table>

<note>
Commands with an asterisk (*) are normally only used by the developer.
</note>

<p>
<c>emerge</c> recursively merges a package and all of its dependencies into 
your file system. This command has many options, try <c>emerge --help</c> for 
a list of them.
</p>

<p>
<c>env-update</c> updates the configuration files (including, but not limited 
to <path>/etc/ld.so.conf</path> and <path>/etc/profile.env</path>) to include 
changes made by installed packages.
</p>

</body>
</section>
<section>
<title>Private Scripts and Commands</title>
<body>

<p>
These are scripts you can use in your ebuild files to perform common tasks.
</p>

<p>
For you down and dirty people, look at the scripts themselves in 
<path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Command</th>
  <th>Default Value</th>
  <th>Description</th>
  <th>Example</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Sets the options used when running <c>dodir</c></ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>N/A</ti>
  <ti>Installs the specified binaries into <path>DESTTREE/bin</path></ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Sets the relative subdir (<e>DOCDESTTREE</e>) used by <c>dodoc</c> 
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>N/A</ti>
  <ti>Creates a directory, handling ${D} transparently</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into the package's documentation directory 
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (see <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files with mode <e>EXEOPTIONS</e> (see 
    <c>exeopts</c>) into <path>EXEDESTTREE</path> (see <c>exeinto</c>)
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>N/A</ti>
  <ti>Creates a hard link, handling ${D} transparently</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files and directories into 
    <path>/usr/share/doc/${PF}/html</path> 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into /usr/share/info, then compresses them 
    with gzip 
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files with mode <c>INSOPTIONS</c> (see 
    <c>insopts</c>) into <path>INSDESTTREE</path> (see <c>insinto</c>)
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0644 
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0644
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0755
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into <path>/usr/share/man/manX</path>, 
    according to the suffix of the file (file.1 will go into <path>man1</path>)
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the files into <path>DESTTREE/sbin</path>, making sure they are 
    executable
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>N/A</ti>
  <ti>Creates a symlink, handles ${D} transparently</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>N/A</ti>
  <ti>
    Runs make with <c>MAKEOPTS</c>.  some packages cannot be made in parallel;
    use <c>emake -j1</c> instead
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Sets the root (<e>EXEDESTTREE</e>) for the <c>doexe</c> command</ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Sets the options used when running <c>doexe</c></ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>N/A</ti>
  <ti>
    Applies the specified ownership to the specified file via the chown 
    command, handles ${D} transparently
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>N/A</ti>
  <ti>
    Applies the specified permissions to the specified file via the chmod 
    command, handles ${D} transparently
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Sets the root (<e>INSDESTTREE</e>) for the <c>doins</c> command</ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Sets the options used when running <c>doins</c></ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Sets the target prefix (<path>DESTTREE</path>) for all the 'do' commands 
    (like <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, 
    <c>domo</c>, <c>dosbin</c>)
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Sets the options used when running <c>dolib</c></ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dobin</c> which installs the specified binary 
    transparently renaming to the second argument
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dodoc</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doexe</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doins</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doman</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dosbin</c> which installs the specified file transparently
    renaming to the second argument
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>N/A</ti>
  <ti>
    Runs <c>prepallman</c>, <c>prepallinfo</c> and <c>prepallstrip</c>.  Also 
    ensures all libraries in <path>/opt/*/lib</path>, <path>/lib</path>, 
    <path>/usr/lib</path> and <path>/usr/X11R6/lib</path> are executable.  also 
    moves any stray aclocal macros into <path>/usr/share/aclocal</path>
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>N/A</ti>
  <ti>
    Recursively gzips all doc files in <path>/usr/share/doc</path>, 
    transparently fixing up any symlink paths
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>N/A</ti>
  <ti>Recursively gzips all info files in <path>/usr/share/info</path></ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>N/A</ti>
  <ti>
    Recursively gzips all man pages in <path>/opt/*/man/*</path>, 
    <path>/usr/share/man/*</path>, <path>/usr/local/man/*</path>, 
    <path>/usr/X11R6/share/man/*</path> and transparently fixes up any symlink 
    paths
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</section>
</chapter>
<chapter>
<title>Package Dependencies</title>
<section>
<title>Why dependencies are important</title>
<body>

<p>
Portage is more than just a convenience script that gives you a unified
way to build any one project (program, library) from source.  It will also
fetch and install any necessary dependencies if you take care to specify
these in your ebuild.
</p>

<p>
In the official ebuilds, all dependencies have already been specified,
so when you issue <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage will
insure that all libraries necessary for Mozilla to build and run are
properly installed before Mozilla itself is built.
</p>

<p>
Portage even distinguishes between build-time dependencies and run-time
dependencies. (Caveat: Currently, Portage installs all build-time and run-time
dependencies and leaves it at that. At a later stage, it will be possible to
trim your installation so that only the run-time dependencies are left 
installed).
</p>

</body>
</section>
<section>
<title>How to Specify Dependencies in Your ebuild Files (a.k.a. DEPEND Atoms)</title>
<body>

<p>
The <c>DEPEND</c> variable inside your <path>foo-x.y.z.ebuild</path> tells 
Portage about which packages are needed to build <path>foo</path>.  The 
<c>RDEPEND</c> variable specifies which packages are needed for <path>foo</path>
to run.
</p>

<pre caption="Depend example">
DEPEND="virtual/glibc
        sys-libs/zlib"
RDEPEND="virtual/glibc"
</pre>

<p>
This tells Portage that to build <path>foo-x.y.z</path>, the packages
<path>virtual/glibc</path> (more on  virtuals in a bit) and 
<path>sys-libs/zlib</path> are needed.  It does not say anything about which 
version of glibc or zlib that are needed, which means "anything goes".
</p>

<p>
The "anything goes" is of course a bit scary, and will not work in the general 
case. But for central libraries like glibc, which strives very hard to be 100% 
binary compatible all the time, it actually works. For other libraries, we can 
of course specify version dependencies.
</p>

<pre caption="Version example">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= and = do what you would expect; sys-apps/bar version 1.2 or newer is okay
(this means that sys-apps/bar-2.0 is okay), while sys-apps/baz version 1.0 is 
the only version that is accepted. For more information on the version schema of
packages, see the section above on <uri link="#doc_chap2_sect2">Naming ebuild 
Files</uri>. 
</p>

<p>
Other methods of specifying version dependencies are follow:
</p>

<pre caption="Specifying version dependencies">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 will select the newest portage revision of qux-1.0.
</p>

<p>
=sys-apps/foo-1.2* will select the newest member of the 1.2 series, but will 
ignore 1.3 and later/earlier series.  That is, foo-1.2.3 and foo-1.2.0 are both
valid, while foo-1.3.3, foo-1.3.0, and foo-1.1.0 are not.
</p>

<p>
!sys-libs/gdbm will prevent this package from being emerged while gdbm is 
already emerged.
</p>

<note>
For all the latest details about these DEPEND Atoms, please see the section 5 
manpage on ebuilds.  <c>man 5 ebuilds</c>.
</note>

</body>
</section>
</chapter>

<chapter>
<title>Testing and deploying</title>
<section>
<title>ChangeLog</title>
<body>

<p>
Whenever you update a (or write a new) ebuild, you must also update its (or
create a new) ChangeLog.  The <path>skel.ChangeLog</path> contains a sample
ChangeLog that you can use as a basis.
</p>

<p>
The purpose of the ChangeLog is to document <e>what</e> is being done, 
<e>why</e> it is being done, and by <e>whom</e>.  This allows both 
developers and users to trace the changes made in an easy way.
</p>

<p>
The ChangeLog is primarily targeted at users, so be sure to keep your
writing short, to the point, and avoid getting verbose about the internal
technical details.
</p>

</body>
</section>

<section>
<title>Storing your own ebuilds locally</title>
<body>

<p>
In order to be able to test your ebuilds and let Portage know about them, you 
must place those in a known directory.  Portage will use the 
<c>PORTDIR_OVERLAY</c> variable which you can define in 
<path>/etc/make.conf</path>.  You should set this variable to your directory 
(e.g. <path>/usr/local/portage</path>).
</p>

<p>
In that directory, you must use the same structure (and categories) as in 
<path>/usr/portage</path>. 
</p>

<p>
Using this <c>PORTDIR_OVERLAY</c>, your ebuilds remain on your system, even
after an <c>emerge sync</c>, and they are still known to Portage.
</p>

</body>
</section>

<section>
<title>Useful testing tools</title>
<body>

<p>
We have a few useful tools to help you with writing and maintaining your 
ebuilds.
</p>

<warn>
<c>lintool</c> is broken. Use repoman instead. 
</warn>

<table>
<tr>
  <th>Tool</th>
  <th>Package</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Developer-only tool to assist with the CVS checkin procedure.  It does a 
    lot of common QA and tries to make sure that files added to cvs will not 
    break the portage tree.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Tool that keeps pre-processed files so that recompilation gets done 
    <e>much</e> faster.  Be sure to add <c>ccache</c> to the <c>FEATURES</c> 
    variable in <path>/etc/make.conf</path>!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Launch a shell that creates a sandbox environment.  Useful for entering the
    same environment that portage builds packages inside of and debugging 
    things by hand.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>Can create a new ChangeLog or add an entry to an existing one.</ti>
</tr>
<tr>
  <ti><c>gentool-bump-revision</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>
    Developer-only tool that bumps the revision number, adds the new revision 
    to CVS, removed the old revision and updates the ChangeLog accordingly.
  </ti>
</tr>
<tr>
  <ti><c>qpkg</c></ti>
  <ti>app-portage/gentoolkit</ti>
  <ti>A tool to gather misc information about installed packages.</ti>
</tr>
</table>

</body>
</section>
</chapter>
</guide>
 
